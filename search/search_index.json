{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyBDY Documentation","text":""},{"location":"#pybdy-documentation","title":"pyBDY Documentation","text":"<p>Welcome to the documentation for pyBDY (NEMO lateral boundary conditions)</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p>pyBDY is a python package to generate lateral boundary conditions for regional NEMO model configurations. It has been developed to uses geographical and depth information from an a source data (e.g. a global ocean simulation) and translate them to a destination NEMO region simulation. It makes use of a kdtree approximate nearest neighbour algorithm in order to provide a generic method of weighted average interpolation for any flavour of ocean model. The available options are accessed through a NEMO style namelist.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>How to cite </li> <li>Change Log </li> <li>Dependencies </li> <li>Quick Start Installation </li> <li>How to use pyBDY </li> <li>Worked Example </li> <li>Tidal Boundary Conditions Generation </li> <li>Troubleshooting </li> <li>pyBDY Module Structure </li> </ul>"},{"location":"#how-to-cite","title":"How to cite","text":"<p>Back to top</p> <p>Please cite pyBDY version 0.4.0 in your work using:</p> <p>Harle, J., Barton, B.I., Nagella, S., Crompton, S., Polton J., Patmore, R., Morado, J., Prime, T., Wise, A., De Dominicis, M., Blaker, A. Farey, J.K., (2025). pyBDY - NEMO lateral boundary conditions v0.4.0 [Software]. https://doi.org</p> <p></p>"},{"location":"#change-log","title":"Change Log","text":"<p>Back to top</p> <p>The lastes version of pyBDY is version 0.4.0. The changes relative to the previous version (0.3.0) are:</p> <ul> <li>Sigma to sigma vertical layer interpolation is now possible.</li> <li>Vertical interpolation in pyBDY can now be turned off for zco vertical coodinate data.</li> <li>The namelist has been streamlined to removed variables that are no longer used.</li> <li>Time input in the namelist has changed to offer more granularity.</li> <li>Grid variables names are now specified using a .json file instead of .ncml. Source data is still specified with .nmcl.</li> <li>The boundary is split into chunks to allow for processing smaller sections of data.</li> <li>Boundaries that cross an east - west wrap in source data can be processed.</li> <li>The 1-2-1 horizontal filter has been turned off.</li> <li>The seawater dependancy updated to gsw.</li> <li>A plotting masking bug has been fixed.</li> <li>There is now horizontal flood filling that will remove zeros from salinity and temperature near land.</li> <li>Bug fix for 90 boundaries that meet diagonally to produce a 90 degree corner.</li> <li>Some unit tests have been added and full integration tests.</li> <li>Documentation has been updated and restructured.</li> <li>sn_src_zgr_type and sn_dst_zgr_type are defined in the namelist.bdy</li> </ul> <p>There is a new library for generating NEMO initial conditions called pyIC. pyIC can be found at: https://github.com/NOC-MSM/pyIC</p> <p></p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Back to top</p> <p>pyBDY is installed under a conda/mamba environment to aid wider distribution and to facilitate development. The key dependecies are listed below:</p> <ul> <li>python=3.9</li> <li>netCDF4</li> <li>scipy</li> <li>numpy</li> <li>xarray</li> <li>matplotlib</li> <li>cartopy</li> <li>thredds_crawler</li> <li>seawater</li> <li>pyqt5</li> <li>pyjnius</li> <li>cftime</li> <li>gsw</li> </ul> <p>A recent JAVA installation is also required.</p> <p></p>"},{"location":"#quick-start-installation","title":"Quick Start Installation","text":"<p>Back to top</p> <p>To get started, check out and set up an instance of the pyBDY GitHub repository:</p> <pre><code>export PYBDY_DIR=$PWD/pyBDY\ngit clone git@github.com:NOC-MSM/pyBDY.git\n</code></pre> <p>**Helpful Tip...</p> <pre><code>- **It is not advised to checkout the respository in your home directory.**\n</code></pre> <p>Creating a specific conda virtual environment is highly recommended (click here for more about virtual enviroments). Load conda (e.g. through anaconda/miniforge) and create the environment through the provided <code>environment.yml</code> file.</p> <pre><code>cd $PYBDY_DIR\nconda env create -n pybdy -f environment.yml\n</code></pre> <p>Activate the new environment</p> <pre><code>conda activate pybdy\n</code></pre> <p>Install pyBDY</p> <pre><code>pip install -e .\n</code></pre> <p>Make sure the Java Runtime Environment is set:</p> <pre><code>export JAVA_HOME=path_to_jre\n</code></pre> <p>Generalised methods for defining paths are as follows:</p> <pre><code>export JAVA_HOME=$(readlink -f $(which java)) # UNIX\nexport JAVA_HOME=$(/usr/libexec/java_home)    # Mac\n</code></pre> <p>To check that pyBDY have been correctly installed in the virtual environment, enter the following command:</p> <pre><code>pybdy -v\n</code></pre> <p>If it has you should see the help usage prompt:</p> <pre><code>usage: pybdy -s &lt;namelist.bdy&gt;\n</code></pre> <p>If not please see the troubleshooting pages for common causes as to why the installation may fail.</p> <p>To deactivate the conda environment:</p> <pre><code>conda deactivate\n</code></pre> <p></p>"},{"location":"#how-to-use-pybdy","title":"How to use pyBDY","text":"<p>Back to top</p> <p>In this documentation \"bdy points\" refer to the output boundary points generated by pyBDY. First follow the installation instructions Quick Start Installation.</p>"},{"location":"#step-1-file-preparation","title":"Step 1: File Preparation","text":"<p>Copy and paste the following files into your working directory:</p> <ul> <li> <p><code>inputs/namelist_local.bdy</code></p> </li> <li> <p><code>inputs/grid_name_map.json</code></p> </li> <li> <p><code>inputs/src_data_local.ncml</code></p> </li> <li> <p><code>namelist.bdy</code>: Specifies file paths and configuration options.</p> </li> <li> <p><code>grid_name_map.json</code>: Defines variable names in horizontal and vertical grid files.</p> </li> <li> <p><code>src_data.ncml</code>: Aggregates and remaps source data variables for PyBDY.</p> </li> </ul>"},{"location":"#step-2-edit-the-namelist-namelist_localbdy","title":"Step 2: Edit the Namelist <code>namelist_local.bdy</code>","text":"<p>Descriptions of all required variables are in <code>src/pybdy/variable.info</code>. Here we will summarise the main variables that will need changing to get started.</p>"},{"location":"#key-namelist-parameters","title":"Key Namelist Parameters","text":"<ul> <li><code>sn_src_zgr_type</code></li> <li><code>sn_dst_zgr_type</code></li> <li><code>sn_src_hgr</code></li> <li><code>sn_src_zgr</code></li> <li><code>sn_dst_hgr</code></li> <li><code>sn_dst_zgr</code></li> <li><code>sn_src_msk</code></li> <li><code>sn_bathy</code></li> <li><code>sn_nme_map</code></li> <li><code>sn_src_dir</code></li> <li><code>sn_dst_dir</code></li> <li><code>cn_mask_file</code></li> <li><code>ln_zinterp</code></li> <li><code>nn_rimwidth</code></li> </ul>"},{"location":"#vertical-grid-type","title":"Vertical grid type","text":"<ul> <li><code>sn_src_zgr_type</code>: The source vertical coordinate type. This can be 'zco', 'zps' or 'sco'. 'zco' for the z-coordinate full step which are not spatially verying, 'zps' for z-coordinate - partial steps which have some adjustment in height near the seabed and 'sco' for sigma or hybrid z-sigma-coordinates which get thicker or thinner depending on the bathymetry.</li> <li><code>sn_dst_zgr_type</code>: Same as <code>sn_src_zgr_type</code> but for destination vertical coordinate type.</li> </ul>"},{"location":"#file-paths","title":"File Paths","text":"<p>Directory paths in bdy file can be relative or absolute. The application picks the relative path from the current working directory.</p> <ul> <li> <p><code>sn_src_hgr</code>: Source horizontal grid file. Use <code>ncdump -h</code> or <code>ncview</code> to inspect variables. The variable names are mapped in grid_name_map.json. Map extra variable names in <code>grid_name_map.json</code> to avoid recalculation. See Step 4: Setting up the JSON file for variable descriptions and requirements.</p> </li> <li> <p><code>sn_src_zgr</code>: Source vertical grid file. The file may be the same file as <code>sn_src_hgr</code>. The variable names are mapped in grid_name_map.json. Map extra variables like <code>gdepw</code>, <code>gdepu</code>, <code>e3w</code> in <code>grid_name_map.json</code> to avoid recalculation. Note: Time-varying depths are not used in PyBDY. See Step 4: Setting up the JSON file for variable descriptions and requirements.</p> </li> <li> <p><code>sn_dst_hgr</code>, <code>sn_dst_zgr</code>: Destination equivalents of the above.</p> </li> <li> <p><code>sn_src_msk</code>: Source mask file with variables:</p> <ul> <li><code>tmask</code>, <code>umask</code>, <code>vmask</code>, <code>fmask</code></li> </ul> </li> <li> <p><code>sn_bathy</code>: Destination bathymetry file with variable:</p> <ul> <li> <p><code>Bathymetry</code></p> </li> <li> <p>Used to calculate boundary mask if <code>ln_mask_file</code> is unset.</p> </li> <li> <p>Can be computed from <code>e3w</code> and <code>bottom_level</code>:</p> <pre><code>gdepw = np.cumsum(e3w, axis=1)\ngrid = np.indices(bottom_level.shape)\nbathy = gdepw[bottom_level, grid[0], grid[1]]\n</code></pre> </li> </ul> </li> <li> <p><code>sn_nme_map</code>: Path to <code>grid_name_map.json</code></p> <ul> <li>Note: <code>ncml</code> is no longer used for grid input. Use <code>grid_name_map.json</code> instead.</li> <li>See Step 4: Setting up the JSON file for variable descriptions and <code>inputs/grid_name_map_readme.txt</code>.</li> </ul> </li> <li> <p><code>sn_src_dir</code>: Path to <code>src_data.ncml</code></p> <ul> <li>This is an NcML (XML) file that points to source data (not grid) paths. It can also include THREDDS URLs (see <code>inputs/namelist_remote.bdy</code> for example).</li> <li>More detail on setting up the NcML file is in Step 3: Setting up the NcML file.</li> </ul> </li> <li> <p><code>sn_dst_dir</code>: Output directory for PyBDY data</p> </li> <li> <p><code>cn_mask_file</code> (optional): Used to define open boundaries.</p> <ul> <li>Values: <code>-1</code> (out-of-domain), <code>0</code> (land), <code>1</code> (water)</li> <li>If not provided, PyBDY uses bathymetry to infer boundaries</li> </ul> </li> </ul>"},{"location":"#other-settings","title":"Other Settings","text":"<ul> <li> <p><code>ln_dyn2d</code>: used to turn on barotropic velocities in boundary processing.</p> </li> <li> <p><code>ln_dyn3d</code>: used to turn on total velocities in boundary processing. Note this is not baroclinic velocities, which is important when running NEMO. You may want ln_dyn2d and ln_dyn3d if testing but usually one of them is sufficient as long as it matches your NEMO namelist setup.</p> </li> <li> <p><code>ln_tra</code>: used to turn on tracers temperature and salinity in the boundary processing.</p> </li> <li> <p><code>ln_ice</code>: used to turn on ice boundary conditions so that <code>ice1</code>, <code>ice2</code> and <code>ice3</code> are processed.</p> </li> <li> <p><code>ln_zinterp</code>: Disables vertical interpolation if <code>false</code> and source (parents) must use zco vertical levels.</p> <ul> <li>Output will match source vertical levels.</li> <li>If source uses zps or sco, this will be automatically set to <code>true</code> during run-time.</li> </ul> </li> <li> <p><code>nn_rimwidth</code>: Number of interior boundary points to generate</p> <ul> <li>Typical value: <code>9</code></li> <li>For tidal boundaries: <code>1</code></li> </ul> </li> </ul>"},{"location":"#time-settings","title":"Time Settings","text":"<ul> <li>Ensure <code>time_counter</code> exists in source files</li> <li>Files must be time-ascending</li> <li>NetCDF time metadata must include:<ul> <li><code>calendar</code>: <code>\"gregorian\"</code>, <code>\"noleap\"</code>, or <code>\"360_day\"</code></li> <li><code>units</code>: <code>\"seconds since YYYY-MM-DD hh:mm:ss\"</code></li> </ul> </li> </ul>"},{"location":"#required-namelist-time-parameters","title":"Required Namelist Time Parameters","text":"<ul> <li><code>sn_date_start</code>: Start date for output (format: <code>YYYY-MM-DD</code>)</li> <li><code>sn_date_end</code>: End date for output (format: <code>YYYY-MM-DD</code>)<ul> <li>The start date and end date of output must fall within the source data time range.</li> </ul> </li> <li><code>sn_dst_calendar</code>: Output calendar format</li> <li><code>sn_date_origin</code>: Time counter reference date for output (format: <code>YYYY-MM-DD</code>)</li> <li><code>ln_time_interpolation</code>: If <code>true</code>, interpolate to daily steps.<ul> <li>If <code>false</code>, output uses source data calendar (monthly steps only)</li> </ul> </li> </ul>"},{"location":"#step-3-setting-up-the-ncml-file","title":"Step 3: Setting up the NcML file","text":"<ul> <li>The NcML file has wrappers like:<ul> <li><code>&lt;netcdf&gt;</code> which specifies a single NetCDF file or dataset reference. The top level in the example below declares a virtual NetCDF dataset.</li> <li><code>&lt;aggregation&gt;</code> virtually combine multiple NetCDF files into a single dataset. It has attributes <code>type</code> and <code>dimName</code>. The <code>type</code> of combination can be <code>joinExisting</code> or <code>union</code>. The <code>dimName</code> specifies the dimension along which to join files.</li> <li><code>&lt;scan&gt;</code> is used inside the <code>&lt;aggregation&gt;</code> wrapper to find multiple NetCDF files in a directory. This is instead of or in addition to listing them manually with several <code>&lt;netcdf location=\"./example_path.nc\"/&gt;</code> wrappers. <code>&lt;scan&gt;</code> has attributes like <code>location</code> which gives the path to search, <code>suffix</code> which gives the file ending and <code>regExp</code> which can provide a search expression using Regular Expression (Regex) format. Regex is a special text string that can be used in the NcML file for describing a search pattern to match against some text. You may compare using Regex to filter what files to include in your datasets against using wildcard (*) to specify a file search pattern in your computer. More information on Regex patterns can be found here Regex.</li> <li><code>&lt;dimension&gt;</code> is a wrapper that allows for renaming a dimension (e.g. time_counter).</li> <li><code>&lt;variable&gt;</code> is a wrapper that allows for renaming or modifying a variable or variable attributes (e.g. units).</li> <li><code>&lt;rename&gt;</code> maps a variable or dimension from its original name to a new name. It must be placed inside a <code>&lt;variable&gt;</code> or <code>&lt;dimension&gt;</code> wrapper. Variable names can be remapped in a way that only affects the reading of the file whithout modifying the original NetCDF file. This can be useful if the source (parent) data does not have the variables named in the standard way pybdy expects. The renaming can be do using <code>&lt;variable name=\"v1\"&gt;</code> and <code>&lt;rename name=\"v2\"&gt;</code> where the \"v1\" is the original name and \"v2\" is the new name.</li> </ul> </li> <li>The dimensions that pybdy expects in the source data are:<ul> <li><code>time_counter</code> - this is the required time dimension name</li> <li>dimensions in variables must be ordered <code>time_counter</code>, <code>depth</code>, <code>y</code>, <code>x</code> if 4 dimensional or ordered <code>time_counter</code>, <code>y</code>, <code>x</code> if 3 dimensional.</li> </ul> </li> <li>The variables that pybdy expects in the source data are:<ul> <li><code>votemper</code> - the water temperature</li> <li><code>votemper</code> - the water salinity</li> <li><code>sossheig</code> - the sea surface height</li> <li><code>vozocrtx</code> - the u (northward) component of velocity</li> <li><code>vomecrty</code> - the v (eastward) component of velocity</li> <li><code>ice1</code> - a sea ice parameter</li> <li><code>ice2</code> - a sea ice parameter</li> <li><code>ice3</code> - a sea ice parameter</li> </ul> </li> <li>See <code>inputs</code> folder for more examples.</li> </ul> <p>Example structure combining data on the T grid, U grid and V grid each along the time dimension then aggregating them together into a single virtual file:</p> <pre><code>&lt;ns0:netcdf xmlns:ns0=\"http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2\" title=\"aggregation example\"&gt;\n  &lt;ns0:aggregation type=\"union\"&gt;\n    &lt;ns0:netcdf&gt;\n      &lt;ns0:aggregation type=\"joinExisting\" dimName=\"time_counter\"&gt;\n        &lt;ns0:scan location=\"/path_to_src_data/Data/\" regExp=\".*grid_T.*\" /&gt;\n      &lt;/ns0:aggregation&gt;\n    &lt;/ns0:netcdf&gt;\n    &lt;ns0:netcdf&gt;\n      &lt;ns0:aggregation type=\"joinExisting\" dimName=\"time_counter\"&gt;\n        &lt;ns0:scan location=\"/path_to_src_data/Data/\" regExp=\".*grid_U.*\" /&gt;\n      &lt;/ns0:aggregation&gt;\n    &lt;/ns0:netcdf&gt;\n    &lt;ns0:netcdf&gt;\n      &lt;ns0:aggregation type=\"joinExisting\" dimName=\"time_counter\"&gt;\n        &lt;ns0:scan location=\"/path_to_src_data/Data/\" regExp=\".*grid_V.*\" /&gt;\n      &lt;/ns0:aggregation&gt;\n    &lt;/ns0:netcdf&gt;\n  &lt;/ns0:aggregation&gt;\n&lt;/ns0:netcdf&gt;\n</code></pre> <p>An example NcML expression renaming a variable in joined NetCDF files:</p> <pre><code>&lt;ns0:netcdf xmlns:ns0=\"http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2\"&gt;\n  &lt;ns0:aggregation type=\"joinExisting\" dimName=\"time_counter\"&gt;\n    &lt;ns0:scan location=\"./monthly/\" suffix=\".nc\" subdirs=\"false\" /&gt;\n    &lt;ns0:variable name=\"temp\"&gt;\n      &lt;ns0:rename name=\"votemper\" /&gt;\n    &lt;/ns0:variable&gt;\n  &lt;/ns0:aggregation&gt;\n&lt;/ns0:netcdf&gt;\n</code></pre>"},{"location":"#step-4-setting-up-the-json-file","title":"Step 4: Setting up the JSON file","text":"<p>The JSON file \"grid_name_map.json\" file provides a way to rename/remap the variables from names in the file netcdf file to the variable names desired by pybdy. This is specifically for the horizontal (hgr) and vertical (zgr) grid files (not data Input/Output). In the past this could be done with a .ncml file but now it done using .json.</p> <p>The \"grid_name_map.json\" file has \"dimension_map\", \"sc_variable_map\" and \"dst_variable_map\", these should not be edited. \"sc\" refers to the source grid and \"dst\" refers to the destination grid. The list of dimensions t, z, y, x under \"dimension_map\" are \"key: value\" pairs, where the \"key\" should be unedited and the \"value\" should be changed to match the name of the respective dimension in your netcdf file. The is the same process for the list of variables under \"variable_map\". The \"variable_map\" is used for both horizontal and vertical grid variable names even if they come from separate files.</p> <p>Below is a decription of each dimension and variable. Not all variables are needed, those that are marked with a * below are optional, if you don't have the optional variable in your netcdf file leave it as the default \"value\" and pybdy will do its best to calculate it. If the variable is available it should be name mapped otherwise pybdy may incorrectly interpret the grid type for example. Variables marked ** may be optional depending on what other variables are provided. In all cases \"t\" should be size 1. Pybdy does not deal with time varying grids.</p> <p>Summary of ideal requirements:</p> <ul> <li>2D grid (or 3D with time dimension = 1) of <code>glamt</code>, <code>gphit</code>, <code>glamu</code>, <code>e1t</code>, <code>e2t</code>, <code>e1u</code>, etc.</li> <li>3D grid (or 4D with time dimension = 1) of <code>gdept</code>, <code>gdepw</code>, <code>e3t</code>, <code>e3w</code>, and 2D grid of <code>mbathy</code> (aka <code>bottom_level</code>)</li> </ul> <p>Summary of minimum requirements:</p> <ul> <li>for the horizontal grid variables we need at least <code>nav_lat</code>, <code>nav_lon</code> on a 2D grid.</li> <li>for the vertical grid variables we have several possible variations ordered by preference:     1.<code>gdept</code> or <code>e3t</code> are specified on 3D grids (Note et3 is sometimes called et3_0 i.e. non-time varying, but has dimensions t, z, y, x, in this case specify <code>\"et3\": \"et3_0\"</code>).     2. 1D depth (or 2D with dimension time and z) <code>gdept_0</code> is specified in addition to <code>mbathy</code>.     3. If <code>mbathy</code> is missing in the source grid, use <code>gdept_0</code> (1D depth) and specify any 2D field (e.g., <code>\"mbathy\": \"nav_lon\"</code>) for <code>mbathy</code> Not recommended for destination (sn_dst_zgr).     4. <code>deptht_bounds</code> is not the same at <code>gdept</code>. If it is the only option you need to use it to calculate <code>gdept</code> yourself.</li> </ul> <pre><code>\"dimension_map\"\n\n\"t\" = time dimension (size 1)\n\"z\" = depth dimension\n\"y\" = horizontal dimension often aligned with latitude\n\"x\" = horizontal dimension often aligned with longitude\n\n\"sc_variable_map\" and \"dst_variable_map\" which refer to sc (source grid variables in \"sn_src_hgr\",\n\"sn_src_zgr\") and dst (destination grid variables in \"sn_dst_hgr\", \"sn_dst_zgr\")\n\n\"nav_lon\" = ** Longitude on t-grid (dims [y, x])\n            (only needed if glamt is not present in the file)\n\"nav_lat\" = ** Latitude on t-grid (dims [y, x])\n            (only needed if gphit is not present in the file)\n\"glamt\" = Longitude on t-grid (dims [t, y, x])\n\"gphit\" = Latitude on t-grid (dims [t, y, x])\n\"glamf\" = * Longitude on f-grid (dims [t, y, x])\n\"gphif\" = * Latitude on f-grid (dims [t, y, x])\n\"glamu\" = * Longitude on u-grid (dims [t, y, x])\n\"gphiu\" = * Latitude on u-grid (dims [t, y, x])\n\"glamv\" = * Longitude on v-grid (dims [t, y, x])\n\"gphiv\" = * Latitude on v-grid (dims [t, y, x])\n\"e1t\" = * scale factor distance between grid cell in x direction on t-grid (dims [t, y, x])\n\"e2t\" = * scale factor distance between grid cell in y direction on t-grid (dims [t, y, x])\n\"e1f\" = * scale factor distance between grid cell in x direction on f-grid (dims [t, y, x])\n\"e2f\" = * scale factor distance between grid cell in y direction on f-grid (dims [t, y, x])\n\"e1u\" = * scale factor distance between grid cell in x direction on u-grid (dims [t, y, x])\n\"e2u\" = * scale factor distance between grid cell in y direction on u-grid (dims [t, y, x])\n\"e1v\" = * scale factor distance between grid cell in x direction on v-grid (dims [t, y, x])\n\"e2v\" = * scale factor distance between grid cell in y direction on v-grid (dims [t, y, x])\n\n\"mbathy\" = ** index of the ocean bottom level (may be called bottom_level) (dims [t, y, x])\n            (only needed if gdept or e3t not given i.e. gdept_0 given. If gdept_0 is the\n            only option and no mbathy is available offer any variable with dims [t, y, x]\n            or dims [y, x])\n\"gdept_0\" = ** 1D depth of levels on t-grid and t-levels (dims [t, z])\n            (only needed if gdept or e3t not given)\n\"gdept\" = ** 3D depth of levels on t-grid and t-levels (dims [t, z, y, x])\n            (only needed if gdept_0 or e3t not given)\n\"gdepu\" = * 3D depth of levels on u-grid and t-levels (dims [t, z, y, x])\n\"gdepv\" = * 3D depth of levels on v-grid and t-levels (dims [t, z, y, x])\n\"gdepf\" = * 3D depth of levels on f-grid and t-levels (dims [t, z, y, x])\n\"gdepw\" = * 3D depth of levels on t-grid and w-levels (dims [t, z, y, x])\n\"gdepuw\" = * 3D depth of levels on u-grid and w-levels (dims [t, z, y, x])\n\"gdepvw\" = * 3D depth of levels on v-grid and w-levels (dims [t, z, y, x])\n\"e3t\" = ** vertical scale factor distance between t-levels on t-grid (dims [t, z, y, x])\n            (only needed if gdept or gdept_0 not given)\n\"e3w\" = * vertical scale factor distance between w-levels on t-grid (dims [t, z, y, x])\n\"e3u\" = * vertical scale factor distance between t-levels on u-grid (dims [t, z, y, x])\n\"e3v\" = * vertical scale factor distance between t-levels on v-grid (dims [t, z, y, x])\n\"e3f\" = * vertical scale factor distance between t-levels on f-grid (dims [t, z, y, x])\n\"e3uw\" = * vertical scale factor distance between w-levels on u-grid (dims [t, z, y, x])\n\"e3vw\" = * vertical scale factor distance between w-levels on v-grid (dims [t, z, y, x])\n\"e3fw\" = * vertical scale factor distance between w-levels on f-grid (dims [t, z, y, x])\n\n\"ln_zco\" = * flag for zco vertical coordinates 1 for true, 0 for false often provided in domain_cfg.nc\n\"ln_zps\" = * flag for zps vertical coordinates 1 for true, 0 for false often provided in domain_cfg.nc\n\"ln_sco\" = * flag for sco vertical coordinates 1 for true, 0 for false often provided in domain_cfg.nc\n</code></pre>"},{"location":"#step-5-running-pybdy","title":"Step 5: Running pyBDY","text":"<p>To use pyBDY, the following command is entered: (the example will run a benchmarking test):</p> <pre><code>pybdy -s /path/to/namelist/file (e.g. ./inputs/namelist_remote.bdy)\n</code></pre> <p>This command line tool reads a BDY file, extracts boundary data and prepares the data for a NEMO simulation.</p> <p></p>"},{"location":"#worked-example","title":"Worked Example","text":"<p>Back to top</p> <p>Here we show a worked example of how to set up the namelist for a different domain than the examples found in the inputs folder. The example child (destination) here is a regional NEMO model that covers the Indian Ocean and the parent (source) used here is a global NEMO model.</p>"},{"location":"#namelist-file","title":"Namelist File","text":"<p>Below is excerpts from an example namelist.bdy.</p> <p>This sections tells pybdy the vertical coordinate type of the parent (src) and child (dst). In this case the the parent is on constant z-levels and the child is on spatially varying sigma-levels.</p> <pre><code>!------------------------------------------------------------------------------\n!   vertical coordinate\n!------------------------------------------------------------------------------\n   sn_src_zgr_type = 'zco' ! vertical coordinate type: 'zco', 'zps' or 'sco'\n   sn_dst_zgr_type = 'sco' ! vertical coordinate type: 'zco', 'zps' or 'sco'\n                           ! 'zco' is z-coordinate - full    steps\n                           ! 'zps' is z-coordinate - partial steps\n                           ! 'sco' is s- or hybrid z-s-coordinate\n</code></pre> <p>Here the file paths are set. These can be absolute (i.e. starting with \"/\") or relative (i.e. starting with \"./\"). For help with what variables are needed in these files see How to use pyBDY . In the example case, the bathmetry file needed to be calculated before running pybdy. It may also be the case that you need to calculate variables like gdept for the sn_src_zgr file fore running pybdy. For setting up the grid_name_map.json see the JSON file example section below.</p> <pre><code>!------------------------------------------------------------------------------\n!  grid information\n!------------------------------------------------------------------------------\n   sn_src_hgr = '/scratch/India_Test/mesh_mask_ORCA025_light.nc4'\n   sn_src_zgr = '/scratch/India_Test/20241211_restart.nc'\n   sn_dst_hgr = '/scratch/India_Test/domain_cfg.nc'     ! Expects vars found in domain_cfg.nc\n   sn_dst_zgr = '/scratch/India_Test/domain_cfg.nc'     ! Expects vars: {e3u,e3v,e3w,e3t,nav_lat,nav_lon,mbathy}\n   sn_src_msk = '/scratch/India_Test/mask_3D.nc'\n   sn_bathy   = '/scratch/India_Test/domain_cfg_bathy.nc'    ! dst bathymetry w/o time dimension\n                                                                            !Expects vars: {Bathymetry,nav_lat,nav_lon}\n   sn_nme_map = './india_test/grid_name_map.json'     ! json file mapping variable names to netcdf vars\n</code></pre> <p>Here the source (parent) data is specified via the .nmcl file in NcML format. For setting up the src_data_local.ncml see the NcML file example section below. The output directory, file name prefix and <code>\\_FillValue</code> in the netCDF file is specified. The sn_dst_metainfo is set in the netcdf output file <code>history</code> attribute. <code>nn_src_time_adj</code> does not get used???</p> <pre><code>!------------------------------------------------------------------------------\n!  I/O\n!------------------------------------------------------------------------------\n   sn_src_dir = './india_test/src_data_local.ncml' ! src_files/'\n   sn_dst_dir = '/scratch/benbar/India_Test/'\n   sn_fn      = 'india'             ! prefix for output files\n   nn_fv      = -1e20                 !  set fill value for output files\n   nn_src_time_adj = 0                ! src time adjustment\n   sn_dst_metainfo = 'India Data'  ! history info\n</code></pre> <p>Here some options are set. cn_coords_file is a file that can be output by pybdy. In this case, the child (destination) data does not have a pre-defined mask file so pybdy will use the bathymetry provided in sn_bathy to calculate the mask. If the mask produced if not giving the correct boundaries you may need to provide a mask.nc file which you generate. This file contains a 2d mask the same shape as the bathymetry where 1 = \"water\", 0 = \"land\" and -1 = \"out of domain\". Boundary points will be generated between water and \"out of domain\" which can also be where water meets the edge of the defined 2d area. Here, ln_dyn2d will provide a sea surface height (<code>sossheig</code>) variable in the output for barotropic velocities. ln_dyn3d would define total velocities in the in the output if set to true. Here, ln_dyn3d will not include the barotropic component in the 3d velocities but we do not need it because we have ln_dyn2d=true. At least one or the other of ln_dyn2d or ln_dyn3d should be selected and match options in NEMO. Here, ln_tra shows temperature and salinity will be output. ln_ice shows ice will not be output. ln_zinterp shows the vertical interpolation is calculated by pybdy (so should be turned off in NEMO). Here, nn_rimwidth is set to 9 to provide 9 layers of boundary points along all boundaries.</p> <pre><code>!------------------------------------------------------------------------------\n!  unstructured open boundaries\n!------------------------------------------------------------------------------\n    ln_coords_file = .true.               !  =T : produce bdy coordinates files\n    cn_coords_file = 'coordinates.bdy.nc' !  name of bdy coordinates files\n                                          !  (if ln_coords_file=.TRUE.)\n    ln_mask_file   = .false.              !  =T : read mask from file\n    cn_mask_file   = 'mask.nc'            !  name of mask file\n                                          !  (if ln_mask_file=.TRUE.)\n    ln_dyn2d       = .true.               !  boundary conditions for\n                                          !  barotropic fields\n    ln_dyn3d       = .false.              !  boundary conditions for\n                                          !  baroclinic velocities\n    ln_tra         = .true.               !  boundary conditions for T and S\n    ln_ice         = .false.              !  ice boundary condition\n    ln_zinterp     = .true.               !  vertical interpolation\n    nn_rimwidth    = 9                    !  width of the relaxation zone\n</code></pre> <p>In this example we are not producing the tidal forcing on the boundary because ln_tide is set to false. This means the rest of this section does not matter. See Tidal Boundary Conditions Generation  for more on setting up tidal boundaries.</p> <pre><code>!------------------------------------------------------------------------------\n!  unstructured open boundaries tidal parameters\n!------------------------------------------------------------------------------\n    ln_tide        = .false.              !  =T : produce bdy tidal conditions\n    sn_tide_model  = 'FES2014'            !  Name of tidal model. Accepts FES2014, TPXO7p2, or TPXO9v5\n    clname(1)      = 'M2'                 !  constituent name\n    clname(2)      = 'S2'\n    clname(3)      = 'K2'\n    clname(4)      = 'O1'\n    clname(5)      = 'P1'\n    clname(6)      = 'Q1'\n    clname(7)      = 'M4'\n    ln_trans       = .true.               !  interpolate transport rather than\n                                          !  velocities\n    ! location of TPXO7.2 data\n    sn_tide_grid_7p2   = './inputs/tpxo7.2/grid_tpxo7.2.nc'\n    sn_tide_h          = './inputs/tpxo7.2/h_tpxo7.2.nc'\n    sn_tide_u          = './inputs/tpxo7.2/u_tpxo7.2.nc'\n    ! location of TPXO9v5 data: single constituents per file\n    sn_tide_grid_9p5   = './inputs/TPXO9_atlas_v5_nc/grid_tpxo9_atlas_30_v5.nc'\n    sn_tide_dir        = './inputs/TPXO9_atlas_v5_nc/'\n    ! location of FES2014 data\n    sn_tide_fes        = './inputs/FES2014/'\n</code></pre> <p>The time step required in output here are 3 days starting on 12th Dec 2024 (which is also used as the reference date).</p> <pre><code>!------------------------------------------------------------------------------\n!  Time information for output\n!------------------------------------------------------------------------------\n    sn_date_start   = '2024-12-12'    !  dst output date start YYYY-MM-DD\n    sn_date_end     = '2024-12-15'    !  dst output date end YYYY-MM-DD\n    sn_dst_calendar = 'gregorian'     !  output calendar format\n    sn_date_origin  = '2024-12-12'    !  reference for time counter YYYY-MM-DD\n    ln_time_interpolation = .true. !  set to false to use parent\n                                   !  calender for monthly frequency only\n</code></pre> <p>These parameters can be left unchanged. We do not recommend changing them.</p> <pre><code>!------------------------------------------------------------------------------\n!  Additional parameters\n!------------------------------------------------------------------------------\n    nn_wei  = 1                   !  smoothing filter weights\n    rn_r0   = 0.041666666         !  decorrelation distance use in gauss\n                                  !  smoothing onto dst points. Need to\n                                  !  make this a funct. of dlon\n    ln_nemo3p4  = .true.          !  else presume v3.2 or v3.3\n    nn_alpha    = 0               !  Euler rotation angle\n    nn_beta     = 0               !  Euler rotation angle\n    nn_gamma    = 0               !  Euler rotation angle\n    rn_mask_max_depth = 100.0     !  Maximum depth to be ignored for the mask\n    rn_mask_shelfbreak_dist = 20000.0 !  Distance from the shelf break\n</code></pre>"},{"location":"#json-file","title":"JSON File","text":"<p>This is an example .json file: grid_name_map.json. It specifise the names of variables in the source (parent) and destination (child) netCDF grid files. The grid files need to be checked with \"ncdump -h\" and the variable names matched appropriately. It is expected that some of these variables will not be in your grid files. That is not a problem as long at you map the variables that meet the minimum requirements: see How to use pyBDY  for the minimum requirements.</p> <pre><code>{\n  \"dimension_map\": {\n    \"t\": \"t\",\n    \"z\": \"z\",\n    \"y\": \"y\",\n    \"x\": \"x\"\n  },\n  \"sc_variable_map\": {\n    \"nav_lon\": \"nav_lon\",\n    \"nav_lat\": \"nav_lat\",\n    \"glamt\": \"glamt\",\n    \"gphit\": \"gphit\",\n    \"glamf\": \"glamf\",\n    \"gphif\": \"gphif\",\n    \"glamu\": \"glamu\",\n    \"gphiu\": \"gphiu\",\n    \"glamv\": \"glamv\",\n    \"gphiv\": \"gphiv\",\n    \"e1t\": \"e1t\",\n    \"e2t\": \"e2t\",\n    \"e1f\": \"e1f\",\n    \"e2f\": \"e2f\",\n    \"e1u\": \"e1u\",\n    \"e2u\": \"e2u\",\n    \"e1v\": \"e1v\",\n    \"e2v\": \"e2v\",\n    \"mbathy\": \"nav_lon\",\n    \"gdept_0\": \"nav_lev\",\n    \"gdept\": \"gdept\",\n    \"gdepu\": \"gdepu\",\n    \"gdepv\": \"gdepv\",\n    \"gdepf\": \"gdepf\",\n    \"gdepw\": \"gdepw\",\n    \"gdepuw\": \"gdepuw\",\n    \"gdepvw\": \"gdepvw\",\n    \"e3t\": \"e3t\",\n    \"e3w\": \"e3w\",\n    \"e3u\": \"e3u\",\n    \"e3v\": \"e3v\",\n    \"e3f\": \"e3f\",\n    \"e3uw\": \"e3uw\",\n    \"e3vw\": \"e3vw\",\n    \"e3fw\": \"e3fw\",\n    \"ln_zco\": \"ln_zco\",\n    \"ln_zps\": \"ln_zps\",\n    \"ln_sco\": \"ln_sco\"\n  },\n  \"dst_variable_map\": {\n    \"nav_lon\": \"nav_lon\",\n    \"nav_lat\": \"nav_lat\",\n    \"glamt\": \"glamt\",\n    \"gphit\": \"gphit\",\n    \"glamf\": \"glamf\",\n    \"gphif\": \"gphif\",\n    \"glamu\": \"glamu\",\n    \"gphiu\": \"gphiu\",\n    \"glamv\": \"glamv\",\n    \"gphiv\": \"gphiv\",\n    \"e1t\": \"e1t\",\n    \"e2t\": \"e2t\",\n    \"e1f\": \"e1f\",\n    \"e2f\": \"e2f\",\n    \"e1u\": \"e1u\",\n    \"e2u\": \"e2u\",\n    \"e1v\": \"e1v\",\n    \"e2v\": \"e2v\",\n    \"mbathy\": \"bottom_level\",\n    \"gdept_0\": \"gdept_0\",\n    \"gdept\": \"gdept\",\n    \"gdepu\": \"gdepu\",\n    \"gdepv\": \"gdepv\",\n    \"gdepf\": \"gdepf\",\n    \"gdepw\": \"gdepw\",\n    \"gdepuw\": \"gdepuw\",\n    \"gdepvw\": \"gdepvw\",\n    \"e3t\": \"e3t_0\",\n    \"e3w\": \"e3w_0\",\n    \"e3u\": \"e3u_0\",\n    \"e3v\": \"e3v_0\",\n    \"e3f\": \"e3f_0\",\n    \"e3uw\": \"e3uw_0\",\n    \"e3vw\": \"e3vw_0\",\n    \"e3fw\": \"e3fw\",\n    \"ln_zco\": \"ln_zco\",\n    \"ln_zps\": \"ln_zps\",\n    \"ln_sco\": \"ln_sco\"\n  }\n}\n</code></pre>"},{"location":"#ncml-file","title":"NcML File","text":"<p>This is an example NcML file which is used to providing file paths for parent (source) data that pybdy will read in. The example files name is src_data_local.ncml. Here the NcML file combines data on the T grid, U grid and V grid each along the time dimension then aggregating them together into a single virtual file</p> <pre><code>&lt;ns0:netcdf xmlns:ns0=\"http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2\" title=\"aggregation example\"&gt;\n  &lt;ns0:aggregation type=\"union\"&gt;\n    &lt;ns0:netcdf location=\"/scratch/India_Test/mersea.grid_V.nc\" /&gt;\n    &lt;ns0:netcdf location=\"/scratch/India_Test/mersea.grid_U.nc\" /&gt;\n    &lt;ns0:netcdf location=\"/scratch/India_Test/mersea.grid_T.nc\" /&gt;\n  &lt;/ns0:aggregation&gt;\n&lt;/ns0:netcdf&gt;\n</code></pre> <p></p>"},{"location":"#tidal-boundary-conditions-generation","title":"Tidal Boundary Conditions Generation","text":"<p>Back to top</p> <p>By providing a global tidal model dataset (TPXO and FES are currently supported) pyBDY can generate boundary conditions for the NEMO configuration supplied using the namelist file.</p>"},{"location":"#namelist-options","title":"Namelist options","text":"<p>To use the namelist needs to be configured with the required options. These are listed below:</p> <pre><code>ln_tide        = .true.              !  =T : produce bdy tidal conditions\nsn_tide_model  = 'FES2014'           !  Name of tidal model. Accepts FES2014, TPXO7p2, or TPXO9v5\nclname(1)      = 'M2'                !  constituent name\nclname(2)      = 'S2'\nclname(3)      = 'K2'\nclname(4)      = 'O1'\nclname(5)      = 'P1'\nclname(6)      = 'Q1'\nclname(7)      = 'M4'\nln_trans       = .true.              !  interpolate transport rather than velocities\n! location of TPXO7.2 data\nsn_tide_grid_7p2   = './inputs/tpxo7.2/grid_tpxo7.2.nc'\nsn_tide_h          = './inputs/tpxo7.2/h_tpxo7.2.nc'\nsn_tide_u          = './inputs/tpxo7.2/u_tpxo7.2.nc'\n! location of TPXO9v5 data: single constituents per file\nsn_tide_grid_9p5   = './inputs/TPXO9_atlas_v5_nc/grid_tpxo9_atlas_30_v5.nc'\nsn_tide_dir        = './inputs/TPXO9_atlas_v5_nc/'\n! location of FES2014 data\nsn_tide_fes        = './inputs/FES2014/'\n</code></pre> <p>These options define the location of the tidal model datasets, note this differs depending on model as TPXO has all harmonic constants in one netcdf file whereas FES has three separate netcdf files (one for amplitude two for currents) for each constant. Extra harmonics can be appended to the clname(n) list. FES supports 34 constants and TPXO7.2 has 13 to choose from. Other versions of TPXO should work with pyBDY but have not been yet been tested. NOTE FES dataset filenames must have be in the format of constituent then type. e.g.:</p> <pre><code>M2_Z.nc (for amplitude)\nM2_U.nc (for U component of velocity)\nM2_V.nc (for V component of velocity)\n</code></pre> <p>If this is not undertaken the pyBDY will not recognise the files. TPXO data files are specified directly so these can be anyname although it is best to stick with the default names as shown above. So far the tidal model datasets have been downloaded and used locally but could also be stored on a THREDDS server although this has not been tested with the global tide models.</p> <p>Other options include \u201cln_tide\u201d a boolean that when set to true will generate tidal boundaries. \u201csn_tide_model\u201d is a string that defines the model to use, currently only \u201cfes\u201d or \u201ctpxo\u201d are supported. \u201cln_trans\u201d is a boolean that when set to true will interpolate transport rather than velocities.</p>"},{"location":"#harmonic-output-checker","title":"Harmonic Output Checker","text":"<p>There is an harmonic output checker that can be utilised to check the output of pyBDY with a reference tide model. So far the only supported reference model is FES but TPXO will be added in the future. Any tidal output from pyBDY can be checked (e.g. FES and TPXO). While using the same model used as input to check output doesn\u2019t improve accuracy, it does confirm that the output is within acceptable/expected limits of the nearest model reference point.</p> <p>There are differences as pyBDY interpolates the harmonics and the tidal checker does not, so there can be some difference in the values particularly close to coastlines.</p> <p>The checker can be enabled by editing the following in the relevent bdy file:</p> <pre><code>ln_tide_checker = .true.                ! run tide checker on pyBDY tide output\nsn_ref_model    = 'fes'                 ! which model to check output against (FES only)\n</code></pre> <p>The boolean determines if to run the checker or not, this takes place after creating the interpolated harmonics and writing them to disk. The string denotes which tide model to use as reference, so far only FES is supported. The string denoting model is not strictly needed, by default fes is used.</p> <p>The checker will output information regarding the checking to the NRCT log, and also write an spreadsheet to the output folder containing any exceedance values, the closest reference model value and their locations. Amplitude and phase are checked independently, so both have latitude and longitude associated with them. It is also useful to know the amplitude of a exceeded phase to see how much impact it will have so this is also written to the spreadsheet. An example output is shown below, as can be seen the majority of the amplitudes, both the two amplitudes exceedances and the ones associated with the phase exceedances are low (~0.01), so can most likely be ignored. There a few phase exceedances that have higher amplitudes (~0.2) which would potentially require further investigation. A common reason for such an exceedance is due to coastlines and the relevant point being further away from an FES data point.</p> <p>The actual thresholds for both amplitude and phase are based on the amplitude of the output or reference, this is due to different tolerances based on the amplitude. e.g. high amplitudes should have lower percentage differences to the FES reference, than lower ones simply due to the absolute amount of the ampltiude itself, e.g. a 0.1 m difference for a 1.0 m amplitude is acceptable but not for a 0.01 m amplitude. The smaller amplitudes contribute less to the overall tide height so larger percentage differences are acceptable. The same also applies to phases, where large amplitude phases have little room for differences but at lower amplitudes this is less critical so a higher threshold is tolerated.</p> <p>The following power functions are used to determine what threshold to apply based on the reference model amplitude.</p>"},{"location":"#amplitude-threshold","title":"Amplitude Threshold","text":"<pre><code>Percentage Exceedance = 26.933 * Reference Amplitude ^ -0.396\u2019\n</code></pre>"},{"location":"#phases-threshold","title":"Phases Threshold","text":"<pre><code>Phase Exceedance = 5.052 * pyBDY Amplitude ^ -0.60\n</code></pre>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<p>Back to top</p> <p>Always check the pyBDY log file. This is usually saved in the working directory of pyBDY as nrct.log. It gives helpful information which may help to diagnose issues. E.g. ValueErrors that are result of a THREDDS server being down and unable to provide data files.</p> <p>If you get the error message \"Destination touches source i-edge but source is not cylindrical\" or you get the error message \"Destination touches source j-edge but North Fold is not implemented\". There is a plot you can uncomment in pybdy.nemo_bdy_chunk.chunk_bdy() that will show you where pyBDY is attempting to place bdy points.</p> <ul> <li>For \"Destination touches source i-edge but source is not cylindrical\", you may have an open boundary in your mask or bathymetry file that is not inside the domain of the source data. If this is the case you need to edit your mask to be land (i.e. zeros) to block the incorrect open boundary.</li> <li>For \"Destination touches source j-edge but North Fold is not implemented\", your domain probably touches the Arctic North Fold and pyBDY is trying to put an open boundary there. If this is the case you need to edit your mask to be land (i.e. zeros) to block the incorrect open boundary along the north edge of the domain. Do not attept to have a regional model with a boundary crossing the North Fold, this has not be implemented yet.</li> </ul> <p>Check your variable and dimension names match the requirements and are mapped correctly either in the NcML file or JSON for the source data and grid data respectively (see section How to use pyBDY )</p> <p>If you have time interpolation problems read the section Time Settings.</p> <p></p>"},{"location":"#pybdy-module-structure","title":"pyBDY Module Structure","text":"<p>Back to top</p> <p>All the classes, methods and functions in pyBDY can be found in the tab along the top of the page.</p>"},{"location":"grid/","title":"grid package","text":""},{"location":"grid/#grid-package","title":"grid package","text":""},{"location":"grid/#submodules","title":"Submodules","text":""},{"location":"grid/#gridhgr-module","title":"grid.hgr module","text":"<p>Created on Mon Feb 03 18:01:00 2025.</p> <p>@author James Harle @author Benjamin Barton @author Ryan Patmore</p>"},{"location":"grid/#class-gridhgrh_gridhgr_file-name_map_file-logger-dst1","title":"class grid.hgr.H_Grid(hgr_file, name_map_file, logger, dst=1)","text":"<p>Bases: <code>object</code></p>"},{"location":"grid/#method-__init__hgr_file-name_map_file-logger-dst1","title":"method __init__(hgr_file, name_map_file, logger, dst=1)","text":"<p>Master horizontal class.</p>"},{"location":"grid/#parameters","title":"Parameters","text":"<p>hgr_file (str) : string of file for loading hgr data name_map_file (str) : string of file for mapping variable names logger (object) : log error and messages dst (bool) : flag for destination (true) or source (false)</p>"},{"location":"grid/#returns","title":"Returns","text":"<p>H_grid (object) : horizontal grid object</p>"},{"location":"grid/#method-find_hgrid_type","title":"method find_hgrid_type()","text":"<p>Find out what type of hoizontal grid is provided A, B or C.</p>"},{"location":"grid/#method-get_varsvars_want","title":"method get_vars(vars_want)","text":"<p>Get the glam, gphi and e scale factors from file if possible.</p>"},{"location":"grid/#parameters_1","title":"Parameters","text":"<p>vars_want (list) : variables needed from file.</p>"},{"location":"grid/#returns_1","title":"Returns","text":"<p>None : var_list is populated</p>"},{"location":"grid/#gridhgrcalc_e1_e2glam-gphi-ij","title":"grid.hgr.calc_e1_e2(glam, gphi, ij)","text":"<p>Calculate missing scale factor e1 and e2 from glam or gphi.</p>"},{"location":"grid/#parameters_2","title":"Parameters","text":"<p>glam (np.array) : mesh variable glam (lon) [time, j, i] gphi (np.array) : mesh variable gphi (lat) [time, j, i] ij (int) : ij direction 1 (i or x direction) or 2 (j or y direction)</p>"},{"location":"grid/#returns_2","title":"Returns","text":"<p>e (np.array) : horizontal distance scale factor e</p>"},{"location":"grid/#gridhgrcalc_grid_from_tt_mesh-mesh","title":"grid.hgr.calc_grid_from_t(t_mesh, mesh)","text":"<p>Calculate missing glam, gphi or gdep from t-grid.</p>"},{"location":"grid/#parameters_3","title":"Parameters","text":"<p>t_mesh (np.array) : mesh variable glam or gphi on t-grid mesh (str) : grid mesh type (glam, gphi, or gdep of u, v, f)</p>"},{"location":"grid/#returns_3","title":"Returns","text":"<p>mesh_out (dict) : horizontal grid mesh data variable</p>"},{"location":"grid/#gridhgrfill_hgrid_varsgrid_type-grid-missing","title":"grid.hgr.fill_hgrid_vars(grid_type, grid, missing)","text":"<p>Calculate the missing horizontal grid variables and add them to grid.</p>"},{"location":"grid/#parameters_4","title":"Parameters","text":"<p>grid_type (str) : type of horizontal grid (A, B or C) grid (dict) : dictionary of grid data variable missing (list) : list of missing variables to calculate</p>"},{"location":"grid/#returns_4","title":"Returns","text":"<p>grid (dict) : horizontal grid data dictionary</p>"},{"location":"grid/#gridzgr-module","title":"grid.zgr module","text":"<p>Created on Mon Feb 03 18:01:00 2025.</p> <p>@author James Harle @author Benjamin Barton @author Ryan Patmore @author Anthony Wise</p>"},{"location":"grid/#class-gridzgrz_gridzgr_file-zgr_type-name_map_file-hgr_type-e_dict-logger-dst1","title":"class grid.zgr.Z_Grid(zgr_file, zgr_type, name_map_file, hgr_type, e_dict, logger, dst=1)","text":"<p>Bases: <code>object</code></p>"},{"location":"grid/#method-__init__zgr_file-zgr_type-name_map_file-hgr_type-e_dict-logger-dst1","title":"method __init__(zgr_file, zgr_type, name_map_file, hgr_type, e_dict, logger, dst=1)","text":"<p>Master depth class.</p>"},{"location":"grid/#parameters_5","title":"Parameters","text":"<p>zgr_file (str) : string of file for loading zgr data zgr_type (str) : zgr type from namelist zco, zps or sco name_map_file (str) : string of file for mapping variable names hgr_type (str) : horizontal grid type e_dict (dict) : dictionary of e1 and e2 scale factors logger (object) : log error and messages dst (bool) : flag for destination (true) or source (false)</p>"},{"location":"grid/#returns_5","title":"Returns","text":"<p>Depth (object) : Depth object</p>"},{"location":"grid/#method-find_zgrid_typezgr_type","title":"method find_zgrid_type(zgr_type)","text":"<p>Find out what type of vertical grid is provided zco, zps or sigma levels (sco).</p>"},{"location":"grid/#method-get_varsvars_want_1","title":"method get_vars(vars_want)","text":"<p>Get the gdep and e3 scale factors from file if possible.</p>"},{"location":"grid/#parameters_6","title":"Parameters","text":"<p>vars_want (list) : variables needed from file.</p>"},{"location":"grid/#returns_6","title":"Returns","text":"<p>None : var_list is populated</p>"},{"location":"grid/#gridzgrcalc_gdepwgdept","title":"grid.zgr.calc_gdepw(gdept)","text":"<p>Calculate missing gdepw from gdept.</p>"},{"location":"grid/#parameters_7","title":"Parameters","text":"<p>gdept (np.array) : mesh variable gdept on t-grid</p>"},{"location":"grid/#returns_7","title":"Returns","text":"<p>dep_out (np.array) : vertical grid mesh data variable</p>"},{"location":"grid/#gridzgrfill_zgrid_varszgr_type-grid-hgr_type-e_dict-missing","title":"grid.zgr.fill_zgrid_vars(zgr_type, grid, hgr_type, e_dict, missing)","text":"<p>Calculate the missing vertical grid variables and add them to grid.</p>"},{"location":"grid/#parameters_8","title":"Parameters","text":"<p>zgr_type (str) : type of vertical grid (zco, zps or sco) grid (dict) : dictionary of grid data variable hgr_type (str) : horizontal grid type e_dict (dict) : dictionary of e1 and e2 scale factors missing (list) : list of missing variables to calculate</p>"},{"location":"grid/#returns_8","title":"Returns","text":"<p>grid (dict) : vertical grid data dictionary</p>"},{"location":"grid/#gridzgrhoriz_interp_e3_olde_in-var_in-lev","title":"grid.zgr.horiz_interp_e3_old(e_in, var_in, lev)","text":"<p>Horizontally interpolate the vertical scale factors e3u, e3v, e3f.</p> <p>Use the horizontal scale factors to calculate interpolation factors. To interpolate to get e3u or e3v, input var_in as e3t data but for e3f this should be e3u.</p>"},{"location":"grid/#parameters_9","title":"Parameters","text":"<p>e_in (dict) : all horizontal scale factors e1 and e2 in dictionary var_in (np.array) : e scale factor to interpolate from e3t (or e3u for f) lev (str) : grid level type (e3 of u, v, f)</p>"},{"location":"grid/#returns_9","title":"Returns","text":"<p>e3 (np.array) : vertical distance scale factor e3 of lev</p>"},{"location":"grid/#gridzgrhoriz_interp_levt-w-zgr_type-hgr_type","title":"grid.zgr.horiz_interp_lev(t, w, zgr_type, hgr_type)","text":"<p>Horizontally interpolate the vertical scale factors e3 and gdep.</p> <p>For A-Grids, u, v and f values are set to t and w values. For C-Grids, zps or sco verticle coords are used to define u, v, and f. For B-Grids, u and v values are set to f values following zps or sco.</p>"},{"location":"grid/#parameters_10","title":"Parameters","text":"<p>t (np.array) : vertical scale factors e or dep on t points w (np.array) : vertical scale factors e or dep on w points zgr_type (str) : type of vertical grid (zco, zps or sco) hgr_type (str) : horizontal grid type (A, B or C)</p>"},{"location":"grid/#returns_10","title":"Returns","text":"<p>lev (dict) : vertical distance scale factor e or gdep</p>"},{"location":"grid/#gridzgrvert_calc_e3gdep_mid-gdep_top-lev","title":"grid.zgr.vert_calc_e3(gdep_mid, gdep_top, lev)","text":"<p>Calculate missing vertical scale factors e3 from gdep.</p>"},{"location":"grid/#parameters_11","title":"Parameters","text":"<p>gdep_mid (np.array) : mesh variable on t levels gdep_top (np.array) : mesh variable on w levels lev (str) : grid level type (e3 of t, w, u, v)</p>"},{"location":"grid/#returns_11","title":"Returns","text":"<p>e3 (np.array) : vertical distance scale factor e3 of lev</p>"},{"location":"grid/#module-contents","title":"Module contents","text":"<p>a Python based regional NEMO model configuration toolbox.</p>"},{"location":"module_structure/","title":"Module structure","text":"<p>All Module Structure</p> <ul> <li>grid package<ul> <li>Submodules</li> <li>grid.hgr module<ul> <li><code>H_Grid</code><ul> <li><code>H_Grid.__init__()</code></li> <li><code>H_Grid.find_hgrid_type()</code></li> <li><code>H_Grid.get_vars()</code></li> </ul> </li> <li><code>calc_e1_e2()</code></li> <li><code>calc_grid_from_t()</code></li> <li><code>fill_hgrid_vars()</code></li> </ul> </li> <li>grid.zgr module<ul> <li><code>Z_Grid</code><ul> <li><code>Z_Grid.__init__()</code></li> <li><code>Z_Grid.find_zgrid_type()</code></li> <li><code>Z_Grid.get_vars()</code></li> </ul> </li> <li><code>calc_gdepw()</code></li> <li><code>fill_zgrid_vars()</code></li> <li><code>horiz_interp_e3_old()</code></li> <li><code>horiz_interp_lev()</code></li> <li><code>vert_calc_e3()</code></li> </ul> </li> <li>Module contents</li> </ul> </li> <li>pybdy package<ul> <li>Subpackages<ul> <li>pybdy.gui package<ul> <li>Submodules</li> <li>pybdy.gui.mynormalize module</li> <li>pybdy.gui.nemo_bdy_input_window module</li> <li>pybdy.gui.nemo_bdy_mask module</li> <li>pybdy.gui.nemo_bdy_mask_gui module</li> <li>pybdy.gui.nemo_bdy_namelist_edit module</li> <li>pybdy.gui.nemo_ncml_generator module</li> <li>pybdy.gui.nemo_ncml_tab_widget module</li> <li>pybdy.gui.selection_editor module</li> <li>Module contents</li> </ul> </li> <li>pybdy.reader package<ul> <li>Submodules</li> <li>pybdy.reader.directory module</li> <li>pybdy.reader.factory module</li> <li>pybdy.reader.ncml module</li> <li>Module contents</li> </ul> </li> <li>pybdy.tide package<ul> <li>Submodules</li> <li>pybdy.tide.fes2014_extract_HC module</li> <li>pybdy.tide.nemo_bdy_tide module</li> <li>pybdy.tide.nemo_bdy_tide3 module</li> <li>pybdy.tide.nemo_bdy_tide_ncgen module</li> <li>pybdy.tide.tpxo_extract_HC module</li> <li>Module contents</li> </ul> </li> <li>pybdy.utils package<ul> <li>Submodules</li> <li>pybdy.utils.Constants module</li> <li>pybdy.utils.e3_to_depth module</li> <li>pybdy.utils.gcoms_break_depth module</li> <li>pybdy.utils.nemo_bdy_lib module</li> <li>Module contents</li> </ul> </li> </ul> </li> <li>Submodules</li> <li>pybdy.nemo_bdy_chunk module<ul> <li><code>chunk_bdy()</code></li> <li><code>chunk_corner()</code></li> <li><code>chunk_land()</code></li> <li><code>chunk_large()</code></li> </ul> </li> <li>pybdy.nemo_bdy_dst_coord module<ul> <li><code>DstCoord</code></li> </ul> </li> <li>pybdy.nemo_bdy_extr_assist module<ul> <li><code>check_wrap()</code></li> <li><code>distance_weights()</code></li> <li><code>flood_fill()</code></li> <li><code>get_ind()</code></li> <li><code>get_vertical_weights()</code></li> <li><code>get_vertical_weights_zco()</code></li> <li><code>interp_horizontal()</code></li> <li><code>interp_vertical()</code></li> <li><code>valid_index()</code></li> </ul> </li> <li>pybdy.nemo_bdy_extr_tm3 module<ul> <li><code>Extract</code><ul> <li><code>Extract.__init__()</code></li> <li><code>Extract.cal_trans()</code></li> <li><code>Extract.extract_month()</code></li> <li><code>Extract.time_delta()</code></li> <li><code>Extract.time_interp()</code></li> <li><code>Extract.write_out()</code></li> </ul> </li> </ul> </li> <li>pybdy.nemo_bdy_gen_c module<ul> <li><code>Boundary</code><ul> <li><code>Boundary.__init__()</code></li> <li><code>Boundary.fill()</code></li> <li><code>Boundary.find_bdy()</code></li> <li><code>Boundary.remove_duplicate_points()</code></li> <li><code>Boundary.remove_landpoints_open_ocean()</code></li> <li><code>Boundary.unique_rows()</code></li> </ul> </li> </ul> </li> <li>pybdy.nemo_bdy_grid_angle module<ul> <li><code>GridAngle</code><ul> <li><code>GridAngle.__init__()</code></li> <li><code>GridAngle.get_lam_phi()</code></li> <li><code>GridAngle.get_north_dir()</code></li> <li><code>GridAngle.get_seg_dir()</code></li> <li><code>GridAngle.get_sin_cos()</code></li> <li><code>GridAngle.trig_eq()</code></li> </ul> </li> </ul> </li> <li>pybdy.nemo_bdy_ice module<ul> <li><code>BoundaryIce</code><ul> <li><code>BoundaryIce.__init__()</code></li> </ul> </li> </ul> </li> <li>pybdy.nemo_bdy_ncgen module<ul> <li><code>CreateBDYNetcdfFile()</code></li> </ul> </li> <li>pybdy.nemo_bdy_ncpop module<ul> <li><code>write_data_to_file()</code></li> </ul> </li> <li>pybdy.nemo_bdy_scr_coord module<ul> <li><code>ScrCoord</code><ul> <li><code>ScrCoord.__init__()</code></li> </ul> </li> </ul> </li> <li>pybdy.nemo_bdy_setup module<ul> <li><code>Setup</code><ul> <li><code>Setup.__init__()</code></li> <li><code>Setup.refresh()</code></li> <li><code>Setup.variable_info_reader()</code></li> <li><code>Setup.write()</code></li> </ul> </li> <li><code>strip_comments()</code></li> </ul> </li> <li>pybdy.nemo_bdy_source_coord module<ul> <li><code>SourceCoord</code><ul> <li><code>SourceCoord.__init__()</code></li> </ul> </li> </ul> </li> <li>pybdy.nemo_bdy_zgrv2 module<ul> <li><code>get_bdy_depths()</code></li> <li><code>get_bdy_depths_old()</code></li> <li><code>get_bdy_sc_depths()</code></li> </ul> </li> <li>pybdy.nemo_coord_gen_pop module<ul> <li><code>Coord</code><ul> <li><code>Coord.__init__()</code></li> <li><code>Coord.add_vars()</code></li> <li><code>Coord.build_dict()</code></li> <li><code>Coord.closeme()</code></li> <li><code>Coord.create_dims()</code></li> <li><code>Coord.populate()</code></li> <li><code>Coord.set_lenvar()</code></li> </ul> </li> </ul> </li> <li>pybdy.profiler module<ul> <li><code>Grid</code><ul> <li><code>Grid.__init__()</code></li> </ul> </li> <li><code>process_bdy()</code></li> <li><code>write_tidal_data()</code></li> </ul> </li> <li>pybdy.pybdy_exe module<ul> <li><code>main()</code></li> </ul> </li> <li>pybdy.pybdy_ncml_generator module<ul> <li><code>main()</code></li> </ul> </li> <li>pybdy.pybdy_settings_editor module<ul> <li><code>main()</code></li> <li><code>open_settings_dialog()</code></li> <li><code>open_settings_window()</code></li> </ul> </li> <li>pybdy.version module</li> <li>Module contents</li> </ul> </li> </ul>"},{"location":"pybdy.gui/","title":"pybdy.gui package","text":""},{"location":"pybdy.gui/#pybdygui-package","title":"pybdy.gui package","text":""},{"location":"pybdy.gui/#submodules","title":"Submodules","text":""},{"location":"pybdy.gui/#pybdyguimynormalize-module","title":"pybdy.gui.mynormalize module","text":""},{"location":"pybdy.gui/#class-pybdyguimynormalizemynormalizestretchlinear-exponent5-vmidnone-vminnone-vmaxnone-clipfalse","title":"class pybdy.gui.mynormalize.MyNormalize(stretch='linear', exponent=5, vmid=None, vmin=None, vmax=None, clip=False)","text":"<p>Bases: <code>Normalize</code></p> <p>A Normalize class for imshow that allows different stretching functions for astronomical images.</p>"},{"location":"pybdy.gui/#method-__init__stretchlinear-exponent5-vmidnone-vminnone-vmaxnone-clipfalse","title":"method __init__(stretch='linear', exponent=5, vmid=None, vmin=None, vmax=None, clip=False)","text":"<p>Initialise an APLpyNormalize instance.</p> <p>Optional Keyword Parametersument</p> <p>vmin: [ None | float ] :   Minimum pixel value to use for the scaling.</p> <p>vmax: [ None | float ] :   Maximum pixel value to use for the scaling.</p> <p>stretch: [ \u2018linear\u2019 | \u2018log\u2019 | \u2018sqrt\u2019 | \u2018arcsinh\u2019 | \u2018power\u2019 ] :   The stretch function to use (default is \u2018linear\u2019).</p> <p>vmid: [ None | float ] :   Mid-pixel value used for the log and arcsinh stretches. If     set to None, a default value is picked.</p> <p>exponent: [ float ] :   if self.stretch is set to \u2018power\u2019, this is the exponent to use.</p> <p>clip: [ True | False ] :   If clip is True and the given value falls outside the range,     the returned value will be 0 or 1, whichever is closer.</p>"},{"location":"pybdy.gui/#method-inversevalue","title":"method inverse(value)","text":"<p>Maps the normalized value (i.e., index in the colormap) back to image data value.</p> <p>value</p> <p>: Normalized value.</p>"},{"location":"pybdy.gui/#parameters","title":"Parameters","text":""},{"location":"pybdy.gui/#pybdyguinemo_bdy_input_window-module","title":"pybdy.gui.nemo_bdy_input_window module","text":"<p>Created on 21 Jan 2015.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.gui/#class-pybdyguinemo_bdy_input_windowinputwindowsetup","title":"class pybdy.gui.nemo_bdy_input_window.InputWindow(setup)","text":"<p>Bases: <code>QDialog</code></p> <p>Input Window for editing pyBDY settings.</p>"},{"location":"pybdy.gui/#method-__init__setup","title":"method __init__(setup)","text":"<p>Initialise the UI components.</p>"},{"location":"pybdy.gui/#pybdyguinemo_bdy_mask-module","title":"pybdy.gui.nemo_bdy_mask module","text":"<p>Mask Class to hold the mask information and operation on mask.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.gui/#class-pybdyguinemo_bdy_maskmaskbathymetry_filenone-mask_filenone-min_depth2000-shelfbreak_dist2000","title":"class pybdy.gui.nemo_bdy_mask.Mask(bathymetry_file=None, mask_file=None, min_depth=200.0, shelfbreak_dist=200.0)","text":"<p>Bases: <code>object</code></p> <p>Mask holder which reads from a netCDF bathymetry file and stores it in \u2018data\u2019 member variable.</p>"},{"location":"pybdy.gui/#method-__init__bathymetry_filenone-mask_filenone-min_depth2000-shelfbreak_dist2000","title":"method __init__(bathymetry_file=None, mask_file=None, min_depth=200.0, shelfbreak_dist=200.0)","text":"<p>Initialise the Mask data.</p>"},{"location":"pybdy.gui/#method-add_maskindex-roi","title":"method add_mask(index, roi)","text":"<p>Add the masks for the given index values depending on the type of mask selected.</p>"},{"location":"pybdy.gui/#method-apply_border_maskpixels","title":"method apply_border_mask(pixels)","text":"<p>Pixels is number of pixels in the border that need applying mask.</p>"},{"location":"pybdy.gui/#method-apply_mediterrian_mask","title":"method apply_mediterrian_mask()","text":"<p>Apply the mediterrian mask specific for the test bathymetry file.</p>"},{"location":"pybdy.gui/#method-fill_small_regionsindex","title":"method fill_small_regions(index)","text":"<p>Fill the small regions of the selection area and fill them up.</p>"},{"location":"pybdy.gui/#method-mask_type-0","title":"method mask_type = 0","text":""},{"location":"pybdy.gui/#method-min_depth-2000","title":"method min_depth = 200.0","text":""},{"location":"pybdy.gui/#method-remove_maskindex-roi","title":"method remove_mask(index, roi)","text":"<p>Remove the mask for the given index values depending on the type of mask selected.</p>"},{"location":"pybdy.gui/#method-remove_small_regionsindex","title":"method remove_small_regions(index)","text":"<p>Remove the small regions in the selection area and takes only the largest area for mask.</p>"},{"location":"pybdy.gui/#method-reset_mask","title":"method reset_mask()","text":"<p>Reset the data back to no mask with land fill.</p>"},{"location":"pybdy.gui/#method-save_maskmask_file","title":"method save_mask(mask_file)","text":"<p>Read the mask data from the mask file.</p>"},{"location":"pybdy.gui/#method-select_the_largest_region","title":"method select_the_largest_region()","text":"<p>Tide up the mask by selecting the largest masked region.</p> <p>This is to avoid two disconnected masked regions.</p>"},{"location":"pybdy.gui/#method-set_bathymetry_filebathy_file","title":"method set_bathymetry_file(bathy_file)","text":"<p>Read the bathymetry file and sets the land to 0 and ocean to 1.</p>"},{"location":"pybdy.gui/#method-set_mask_filemask_file","title":"method set_mask_file(mask_file)","text":"<p>Read the mask data from the mask file.</p> <p>Assumes the mask file is 2D.</p>"},{"location":"pybdy.gui/#method-set_mask_typemask_type","title":"method set_mask_type(mask_type)","text":"<p>Set the mask type.</p>"},{"location":"pybdy.gui/#method-set_minimum_depth_maskdepth","title":"method set_minimum_depth_mask(depth)","text":""},{"location":"pybdy.gui/#method-shelfbreak_dist-2000","title":"method shelfbreak_dist = 200.0","text":""},{"location":"pybdy.gui/#pybdyguinemo_bdy_mask_gui-module","title":"pybdy.gui.nemo_bdy_mask_gui module","text":"<p>Created on 12 Jan 2015.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.gui/#class-pybdyguinemo_bdy_mask_guimatplotlibwidgetparentnone-masknone-min_depth2000-shelfbreak_dist2000-args-kwargs","title":"class pybdy.gui.nemo_bdy_mask_gui.MatplotlibWidget(parent=None, mask=None, min_depth=200.0, shelfbreak_dist=200.0, *args, **kwargs)","text":"<p>Bases: <code>QWidget</code></p> <p>QWidget class for pyBDY mask plot.</p>"},{"location":"pybdy.gui/#method-__init__parentnone-masknone-min_depth2000-shelfbreak_dist2000-args-kwargs","title":"method __init__(parent=None, mask=None, min_depth=200.0, shelfbreak_dist=200.0, *args, **kwargs)","text":"<p>Initialise the mask, matplot and the navigation toolbar.</p>"},{"location":"pybdy.gui/#method-add_mask","title":"method add_mask()","text":"<p>Add the selected region in the drawing tool to the mask.</p>"},{"location":"pybdy.gui/#method-apply_border_mask","title":"method apply_border_mask()","text":"<p>Apply a mask of given number of pixels at the border of the mask.</p>"},{"location":"pybdy.gui/#method-create_basemap","title":"method create_basemap()","text":"<p>Draws the basemap and contour with mask information.</p>"},{"location":"pybdy.gui/#method-drawing_tool_callbacktoolname","title":"method drawing_tool_callback(toolname)","text":"<p>Run callback for the drawing tool when the signal of change of drawing tool is received.</p>"},{"location":"pybdy.gui/#method-mask_type-0_1","title":"method mask_type = 0","text":""},{"location":"pybdy.gui/#method-min_depth-2000_1","title":"method min_depth = 200.0","text":""},{"location":"pybdy.gui/#method-remove_mask","title":"method remove_mask()","text":"<p>Remove the selected region in the drawing tool from the mask.</p>"},{"location":"pybdy.gui/#method-reset_mask_1","title":"method reset_mask()","text":""},{"location":"pybdy.gui/#method-save_mask_filemask_file","title":"method save_mask_file(mask_file)","text":"<p>Save the mask data to mask_file.</p>"},{"location":"pybdy.gui/#method-set_bathymetry_filebathymetry_filename-mask_file","title":"method set_bathymetry_file(bathymetry_filename, mask_file)","text":"<p>Set the bathymetry file.</p>"},{"location":"pybdy.gui/#method-set_mask_settingsmin_depth-shelfbreak_dist","title":"method set_mask_settings(min_depth, shelfbreak_dist)","text":"<p>Mask settings update.</p>"},{"location":"pybdy.gui/#method-set_mask_typetype","title":"method set_mask_type(type)","text":"<p>Set the mask type.</p>"},{"location":"pybdy.gui/#method-shelfbreak_dist-2000_1","title":"method shelfbreak_dist = 200.0","text":""},{"location":"pybdy.gui/#class-pybdyguinemo_bdy_mask_guinemonavigationtoolbarcanvas-parent","title":"class pybdy.gui.nemo_bdy_mask_gui.NemoNavigationToolbar(canvas, parent)","text":"<p>Bases: <code>NavigationToolbar2QT</code></p> <p>Custom toolbar for the nemo.</p> <p>Includes additional buttons for drawing tool and (add,remove) for mask in addtion to default NavigationToolbar provided by matplotlib.</p>"},{"location":"pybdy.gui/#method-__init__canvas-parent","title":"method __init__(canvas, parent)","text":"<p>Initialise the toolbar.</p>"},{"location":"pybdy.gui/#method-add_maskdummy","title":"method add_mask(*dummy)","text":"<p>Run callback for add mask button clicked.</p>"},{"location":"pybdy.gui/#method-borderdummy","title":"method border(*dummy)","text":"<p>Run callback for border button clicked.</p>"},{"location":"pybdy.gui/#method-drawing_tool","title":"method drawing_tool","text":""},{"location":"pybdy.gui/#method-freehanddummy","title":"method freehand(*dummy)","text":"<p>Run callback for freehand button clicked.</p>"},{"location":"pybdy.gui/#method-get_active_button","title":"method get_active_button()","text":"<p>Return the current active button between freehand and rectangle.</p>"},{"location":"pybdy.gui/#method-max_depth_maskdummy","title":"method max_depth_mask(*dummy)","text":"<p>Enable the minimum height mask.</p>"},{"location":"pybdy.gui/#method-normal_maskdummy","title":"method normal_mask(*dummy)","text":"<p>Enable the normal mask button.</p>"},{"location":"pybdy.gui/#method-rectangledummy","title":"method rectangle(*dummy)","text":"<p>Run callback for rectangel button clicked.</p>"},{"location":"pybdy.gui/#method-remove_maskdummy","title":"method remove_mask(*dummy)","text":"<p>Run callback for remove mask button clicked.</p>"},{"location":"pybdy.gui/#method-resetdummy","title":"method reset(*dummy)","text":"<p>Run callback for reset button clicked.</p>"},{"location":"pybdy.gui/#method-shelf_break_maskdummy","title":"method shelf_break_mask(*dummy)","text":"<p>Enable the shelf break mask button.</p>"},{"location":"pybdy.gui/#method-update_height_maskbtn_id","title":"method update_height_mask(btn_id)","text":"<p>Update the height mask buttons in the interface.</p>"},{"location":"pybdy.gui/#pybdyguinemo_bdy_mask_guiset_iconname","title":"pybdy.gui.nemo_bdy_mask_gui.set_icon(name)","text":"<p>Create an icon based on the file found in the module directory with input name.</p>"},{"location":"pybdy.gui/#pybdyguinemo_bdy_namelist_edit-module","title":"pybdy.gui.nemo_bdy_namelist_edit module","text":"<p>Editor for namelist.bdy file.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.gui/#class-pybdyguinemo_bdy_namelist_editnamelisteditorsetup","title":"class pybdy.gui.nemo_bdy_namelist_edit.NameListEditor(setup)","text":"<p>Bases: <code>QWidget</code></p> <p>GUI for the Namelist file options.</p>"},{"location":"pybdy.gui/#method-__init__setup_1","title":"method __init__(setup)","text":"<p>Initialise the constructor for setting up the gui using the settings.</p>"},{"location":"pybdy.gui/#method-bathymetry_update","title":"method bathymetry_update","text":""},{"location":"pybdy.gui/#method-combo_index_changedvalue-name","title":"method combo_index_changed(value, name)","text":"<p>Run callback for the dropdown in the settings.</p> <p>Run callback when the True/False dropdown for the settings,</p> <p>: which has a boolean value, is changed.</p>"},{"location":"pybdy.gui/#method-init_ui","title":"method init_ui()","text":"<p>Initialise the UI components of the GUI.</p>"},{"location":"pybdy.gui/#method-label_changedvalue-name","title":"method label_changed(value, name)","text":"<p>Run callback when the text is changed in the text box.</p>"},{"location":"pybdy.gui/#method-mask_settings_update","title":"method mask_settings_update","text":""},{"location":"pybdy.gui/#method-mask_update","title":"method mask_update","text":""},{"location":"pybdy.gui/#method-new_settings","title":"method new_settings = {}","text":""},{"location":"pybdy.gui/#method-state_changedstate-name","title":"method state_changed(state, name)","text":"<p>Run callback when the check box state is changed.</p> <p>This updates the bool_setting.</p>"},{"location":"pybdy.gui/#pybdyguinemo_ncml_generator-module","title":"pybdy.gui.nemo_ncml_generator module","text":"<p>Created on 6 Aug 2015.</p> <p>@author: Shirley Crompton, UK Science and Technology Facilities Council</p>"},{"location":"pybdy.gui/#class-pybdyguinemo_ncml_generatorncml_generatorbasefile","title":"class pybdy.gui.nemo_ncml_generator.Ncml_generator(basefile)","text":"<p>Bases: <code>QDialog</code></p> <p>Gui editor to capture user input.</p> <p>This is done for the purpose of generating NCML representation of pybdy source datasets.</p>"},{"location":"pybdy.gui/#method-__init__basefile","title":"method __init__(basefile)","text":"<p>Initialise the UI components.</p>"},{"location":"pybdy.gui/#method-enable_btn_updateenable_btn","title":"method enable_btn_update(enable_btn)","text":""},{"location":"pybdy.gui/#method-enable_tabenable_btn","title":"method enable_tab(enable_btn)","text":""},{"location":"pybdy.gui/#method-generate","title":"method generate()","text":""},{"location":"pybdy.gui/#method-generatencmltabslist","title":"method generateNcML(tabsList)","text":""},{"location":"pybdy.gui/#method-get_fname","title":"method get_fname()","text":""},{"location":"pybdy.gui/#method-get_fname_input","title":"method get_fname_input()","text":""},{"location":"pybdy.gui/#method-indentelem-level0","title":"method indent(elem, level=0)","text":""},{"location":"pybdy.gui/#method-initui","title":"method initUI()","text":""},{"location":"pybdy.gui/#method-url_trawlerurl-expr","title":"method url_trawler(url, expr)","text":""},{"location":"pybdy.gui/#pybdyguinemo_ncml_tab_widget-module","title":"pybdy.gui.nemo_ncml_tab_widget module","text":"<p>Created on 2 Jul 2015.</p> <p>@author: Shirley Crompton, UK Science and Technology Facilities Council</p>"},{"location":"pybdy.gui/#class-pybdyguinemo_ncml_tab_widgetncml_tabtabname","title":"class pybdy.gui.nemo_ncml_tab_widget.Ncml_tab(tabName)","text":"<p>Bases: <code>QWidget</code></p> <p>Tab contents to define child aggregation.</p>"},{"location":"pybdy.gui/#method-__init__tabname","title":"method __init__(tabName)","text":"<p>Initialise the UI components.</p>"},{"location":"pybdy.gui/#method-add_tab","title":"method add_tab()","text":""},{"location":"pybdy.gui/#method-initui_1","title":"method initUI()","text":""},{"location":"pybdy.gui/#method-resetvaluescurrentvaluesnone","title":"method resetValues(currentValues=None)","text":""},{"location":"pybdy.gui/#method-reset_tab","title":"method reset_tab()","text":""},{"location":"pybdy.gui/#method-setwidgetstack","title":"method setWidgetStack()","text":""},{"location":"pybdy.gui/#method-src_combo_changedvar_name","title":"method src_combo_changed(var_name)","text":""},{"location":"pybdy.gui/#method-src_tedit_edited","title":"method src_tedit_edited()","text":""},{"location":"pybdy.gui/#class-pybdyguinemo_ncml_tab_widgetncml_variablevarname-old_name","title":"class pybdy.gui.nemo_ncml_tab_widget.ncml_variable(varName, old_name='')","text":"<p>Bases: <code>object</code></p> <p>convenient class to hold the values for a ncml variable.</p>"},{"location":"pybdy.gui/#method-__init__varname-old_name","title":"method __init__(varName, old_name='')","text":""},{"location":"pybdy.gui/#pybdyguiselection_editor-module","title":"pybdy.gui.selection_editor module","text":"<p>Code has been taken from matlibplot polygon interaction.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.gui/#class-pybdyguiselection_editorboxeditoraxes-canvas","title":"class pybdy.gui.selection_editor.BoxEditor(axes, canvas)","text":"<p>Bases: <code>object</code></p> <p>Box editor is to select area using rubber band sort of drawing rectangle.</p> <p>It uses matplotlib RectangleSelector under the hood.</p>"},{"location":"pybdy.gui/#method-__init__axes-canvas","title":"method __init__(axes, canvas)","text":"<p>Initialise class and creates a rectangle selector.</p>"},{"location":"pybdy.gui/#method-disable","title":"method disable()","text":"<p>Disable or removes the box selector.</p>"},{"location":"pybdy.gui/#method-enable","title":"method enable()","text":"<p>Enable the box selector.</p>"},{"location":"pybdy.gui/#method-line_select_callbackeclick-erelease","title":"method line_select_callback(eclick, erelease)","text":"<p>Run callback to the rectangleselector.</p>"},{"location":"pybdy.gui/#method-polygon-none","title":"method polygon = None","text":""},{"location":"pybdy.gui/#method-reset","title":"method reset()","text":"<p>Reset the Box selector.</p>"},{"location":"pybdy.gui/#method-reset_polygon","title":"method reset_polygon()","text":"<p>Reset rectangle polygon.</p>"},{"location":"pybdy.gui/#class-pybdyguiselection_editorpolygoneditoraxis-canvas","title":"class pybdy.gui.selection_editor.PolygonEditor(axis, canvas)","text":"<p>Bases: <code>object</code></p> <p>Editor for the polygons drawn on the map.</p>"},{"location":"pybdy.gui/#method-__init__axis-canvas","title":"method __init__(axis, canvas)","text":"<p>Initialise the editable polygon object.</p>"},{"location":"pybdy.gui/#method-add_pointxval-yval","title":"method add_point(xval, yval)","text":"<p>Add an new point to the selection list and redraws the selection tool.</p>"},{"location":"pybdy.gui/#method-button_press_callbackevent","title":"method button_press_callback(event)","text":"<p>Run callback to mouse press event.</p>"},{"location":"pybdy.gui/#method-button_release_callbackevent","title":"method button_release_callback(event)","text":"<p>Run callback to mouse release event.</p>"},{"location":"pybdy.gui/#method-delete_datapointevent","title":"method delete_datapoint(event)","text":"<p>Delete the data point under the point in event.</p>"},{"location":"pybdy.gui/#method-disable_1","title":"method disable()","text":"<p>Disable the events and the selection.</p>"},{"location":"pybdy.gui/#method-draw_callbackdummy_event","title":"method draw_callback(dummy_event)","text":"<p>Draw the selection object.</p>"},{"location":"pybdy.gui/#method-draw_line","title":"method draw_line()","text":"<p>Draw the line if available.</p>"},{"location":"pybdy.gui/#method-draw_polygon","title":"method draw_polygon()","text":"<p>Draw polygon if available.</p>"},{"location":"pybdy.gui/#method-enable_1","title":"method enable()","text":"<p>Enable the selection.</p>"},{"location":"pybdy.gui/#method-epsilon-3","title":"method epsilon = 3","text":""},{"location":"pybdy.gui/#method-get_index_under_pointevent","title":"method get_index_under_point(event)","text":"<p>Get the index of the point under the event (mouse click).</p>"},{"location":"pybdy.gui/#method-insert_datapointevent","title":"method insert_datapoint(event)","text":"<p>Insert a new data point between the segment that is closest in polygon.</p>"},{"location":"pybdy.gui/#method-motion_notify_callbackevent","title":"method motion_notify_callback(event)","text":"<p>Run callback for the mouse motion with button press.</p> <p>This is to move the edge points of the polygon.</p>"},{"location":"pybdy.gui/#method-polygon_changedpoly","title":"method polygon_changed(poly)","text":"<p>Redraw the polygon.</p>"},{"location":"pybdy.gui/#method-refresh","title":"method refresh()","text":"<p>Refresh the canvas.</p> <p>This method looks at the list of points available and depending on the number of points</p> <p>: in the list creates a point or line or a polygon and draws them.</p>"},{"location":"pybdy.gui/#method-reset_1","title":"method reset()","text":"<p>Reset the points in the selection deleting the line and polygon.</p>"},{"location":"pybdy.gui/#method-reset_line","title":"method reset_line()","text":"<p>Reset the line i.e removes the line from the axes and resets to None.</p>"},{"location":"pybdy.gui/#method-reset_polygon_1","title":"method reset_polygon()","text":"<p>Reset the polygon ie. removes the polygon from the axis and reset to None.</p>"},{"location":"pybdy.gui/#method-set_visibilitystatus","title":"method set_visibility(status)","text":"<p>Set the visibility of the selection object.</p>"},{"location":"pybdy.gui/#method-show_verts-true","title":"method show_verts = True","text":""},{"location":"pybdy.gui/#module-contents","title":"Module contents","text":""},{"location":"pybdy/","title":"pybdy package","text":""},{"location":"pybdy/#pybdy-package","title":"pybdy package","text":""},{"location":"pybdy/#subpackages","title":"Subpackages","text":"<ul> <li>pybdy.gui package<ul> <li>Submodules</li> <li>pybdy.gui.mynormalize module<ul> <li><code>MyNormalize</code><ul> <li><code>MyNormalize.__init__()</code></li> <li><code>MyNormalize.inverse()</code></li> </ul> </li> </ul> </li> <li>pybdy.gui.nemo_bdy_input_window module<ul> <li><code>InputWindow</code><ul> <li><code>InputWindow.__init__()</code></li> </ul> </li> </ul> </li> <li>pybdy.gui.nemo_bdy_mask module<ul> <li><code>Mask</code><ul> <li><code>Mask.__init__()</code></li> <li><code>Mask.add_mask()</code></li> <li><code>Mask.apply_border_mask()</code></li> <li><code>Mask.apply_mediterrian_mask()</code></li> <li><code>Mask.fill_small_regions()</code></li> <li><code>Mask.mask_type</code></li> <li><code>Mask.min_depth</code></li> <li><code>Mask.remove_mask()</code></li> <li><code>Mask.remove_small_regions()</code></li> <li><code>Mask.reset_mask()</code></li> <li><code>Mask.save_mask()</code></li> <li><code>Mask.select_the_largest_region()</code></li> <li><code>Mask.set_bathymetry_file()</code></li> <li><code>Mask.set_mask_file()</code></li> <li><code>Mask.set_mask_type()</code></li> <li><code>Mask.set_minimum_depth_mask()</code></li> <li><code>Mask.shelfbreak_dist</code></li> </ul> </li> </ul> </li> <li>pybdy.gui.nemo_bdy_mask_gui module<ul> <li><code>MatplotlibWidget</code><ul> <li><code>MatplotlibWidget.__init__()</code></li> <li><code>MatplotlibWidget.add_mask()</code></li> <li><code>MatplotlibWidget.apply_border_mask()</code></li> <li><code>MatplotlibWidget.create_basemap()</code></li> <li><code>MatplotlibWidget.drawing_tool_callback()</code></li> <li><code>MatplotlibWidget.mask_type</code></li> <li><code>MatplotlibWidget.min_depth</code></li> <li><code>MatplotlibWidget.remove_mask()</code></li> <li><code>MatplotlibWidget.reset_mask()</code></li> <li><code>MatplotlibWidget.save_mask_file()</code></li> <li><code>MatplotlibWidget.set_bathymetry_file()</code></li> <li><code>MatplotlibWidget.set_mask_settings()</code></li> <li><code>MatplotlibWidget.set_mask_type()</code></li> <li><code>MatplotlibWidget.shelfbreak_dist</code></li> </ul> </li> <li><code>NemoNavigationToolbar</code><ul> <li><code>NemoNavigationToolbar.__init__()</code></li> <li><code>NemoNavigationToolbar.add_mask()</code></li> <li><code>NemoNavigationToolbar.border()</code></li> <li><code>NemoNavigationToolbar.drawing_tool</code></li> <li><code>NemoNavigationToolbar.freehand()</code></li> <li><code>NemoNavigationToolbar.get_active_button()</code></li> <li><code>NemoNavigationToolbar.max_depth_mask()</code></li> <li><code>NemoNavigationToolbar.normal_mask()</code></li> <li><code>NemoNavigationToolbar.rectangle()</code></li> <li><code>NemoNavigationToolbar.remove_mask()</code></li> <li><code>NemoNavigationToolbar.reset()</code></li> <li><code>NemoNavigationToolbar.shelf_break_mask()</code></li> <li><code>NemoNavigationToolbar.update_height_mask()</code></li> </ul> </li> <li><code>set_icon()</code></li> </ul> </li> <li>pybdy.gui.nemo_bdy_namelist_edit module<ul> <li><code>NameListEditor</code><ul> <li><code>NameListEditor.__init__()</code></li> <li><code>NameListEditor.bathymetry_update</code></li> <li><code>NameListEditor.combo_index_changed()</code></li> <li><code>NameListEditor.init_ui()</code></li> <li><code>NameListEditor.label_changed()</code></li> <li><code>NameListEditor.mask_settings_update</code></li> <li><code>NameListEditor.mask_update</code></li> <li><code>NameListEditor.new_settings</code></li> <li><code>NameListEditor.state_changed()</code></li> </ul> </li> </ul> </li> <li>pybdy.gui.nemo_ncml_generator module<ul> <li><code>Ncml_generator</code><ul> <li><code>Ncml_generator.__init__()</code></li> <li><code>Ncml_generator.enable_btn_update()</code></li> <li><code>Ncml_generator.enable_tab()</code></li> <li><code>Ncml_generator.generate()</code></li> <li><code>Ncml_generator.generateNcML()</code></li> <li><code>Ncml_generator.get_fname()</code></li> <li><code>Ncml_generator.get_fname_input()</code></li> <li><code>Ncml_generator.indent()</code></li> <li><code>Ncml_generator.initUI()</code></li> <li><code>Ncml_generator.url_trawler()</code></li> </ul> </li> </ul> </li> <li>pybdy.gui.nemo_ncml_tab_widget module<ul> <li><code>Ncml_tab</code><ul> <li><code>Ncml_tab.__init__()</code></li> <li><code>Ncml_tab.add_tab()</code></li> <li><code>Ncml_tab.initUI()</code></li> <li><code>Ncml_tab.resetValues()</code></li> <li><code>Ncml_tab.reset_tab()</code></li> <li><code>Ncml_tab.setWidgetStack()</code></li> <li><code>Ncml_tab.src_combo_changed()</code></li> <li><code>Ncml_tab.src_tedit_edited()</code></li> </ul> </li> <li><code>ncml_variable</code><ul> <li><code>ncml_variable.__init__()</code></li> </ul> </li> </ul> </li> <li>pybdy.gui.selection_editor module<ul> <li><code>BoxEditor</code><ul> <li><code>BoxEditor.__init__()</code></li> <li><code>BoxEditor.disable()</code></li> <li><code>BoxEditor.enable()</code></li> <li><code>BoxEditor.line_select_callback()</code></li> <li><code>BoxEditor.polygon</code></li> <li><code>BoxEditor.reset()</code></li> <li><code>BoxEditor.reset_polygon()</code></li> </ul> </li> <li><code>PolygonEditor</code><ul> <li><code>PolygonEditor.__init__()</code></li> <li><code>PolygonEditor.add_point()</code></li> <li><code>PolygonEditor.button_press_callback()</code></li> <li><code>PolygonEditor.button_release_callback()</code></li> <li><code>PolygonEditor.delete_datapoint()</code></li> <li><code>PolygonEditor.disable()</code></li> <li><code>PolygonEditor.draw_callback()</code></li> <li><code>PolygonEditor.draw_line()</code></li> <li><code>PolygonEditor.draw_polygon()</code></li> <li><code>PolygonEditor.enable()</code></li> <li><code>PolygonEditor.epsilon</code></li> <li><code>PolygonEditor.get_index_under_point()</code></li> <li><code>PolygonEditor.insert_datapoint()</code></li> <li><code>PolygonEditor.motion_notify_callback()</code></li> <li><code>PolygonEditor.polygon_changed()</code></li> <li><code>PolygonEditor.refresh()</code></li> <li><code>PolygonEditor.reset()</code></li> <li><code>PolygonEditor.reset_line()</code></li> <li><code>PolygonEditor.reset_polygon()</code></li> <li><code>PolygonEditor.set_visibility()</code></li> <li><code>PolygonEditor.show_verts</code></li> </ul> </li> </ul> </li> <li>Module contents</li> </ul> </li> <li>pybdy.reader package<ul> <li>Submodules</li> <li>pybdy.reader.directory module<ul> <li><code>GridGroup</code><ul> <li><code>GridGroup.__init__()</code></li> <li><code>GridGroup.get_meta_data()</code></li> </ul> </li> <li><code>Reader</code><ul> <li><code>Reader.__init__()</code></li> <li><code>Reader.calculate_time_interval()</code></li> <li><code>Reader.delta_time_interval()</code></li> <li><code>Reader.get_dir_list()</code></li> <li><code>Reader.get_source_timedata()</code></li> <li><code>Reader.grid_type_list</code></li> </ul> </li> <li><code>Variable</code><ul> <li><code>Variable.__init__()</code></li> <li><code>Variable.get_attribute_values()</code></li> <li><code>Variable.get_dimensions()</code></li> <li><code>Variable.set_time_dimension_index()</code></li> <li><code>Variable.time_counter_const</code></li> </ul> </li> </ul> </li> <li>pybdy.reader.factory module<ul> <li><code>GetFile()</code></li> <li><code>GetReader()</code></li> <li><code>NetCDFFile</code><ul> <li><code>NetCDFFile.__init__()</code></li> <li><code>NetCDFFile.close()</code></li> </ul> </li> </ul> </li> <li>pybdy.reader.ncml module<ul> <li><code>GridGroup</code><ul> <li><code>GridGroup.__init__()</code></li> <li><code>GridGroup.get_meta_data()</code></li> <li><code>GridGroup.logger</code></li> <li><code>GridGroup.update_atrributes()</code></li> </ul> </li> <li><code>NcMLFile</code><ul> <li><code>NcMLFile.__init__()</code></li> <li><code>NcMLFile.close()</code></li> </ul> </li> <li><code>Reader</code><ul> <li><code>Reader.__init__()</code></li> <li><code>Reader.close()</code></li> <li><code>Reader.grid_type_list</code></li> <li><code>Reader.time_counter</code></li> </ul> </li> <li><code>Variable</code><ul> <li><code>Variable.__init__()</code></li> <li><code>Variable.get_attribute_value()</code></li> </ul> </li> <li><code>init_jnius()</code></li> </ul> </li> <li>Module contents</li> </ul> </li> <li>pybdy.tide package<ul> <li>Submodules</li> <li>pybdy.tide.fes2014_extract_HC module<ul> <li><code>FesExtract</code><ul> <li><code>FesExtract.__init__()</code></li> <li><code>FesExtract.interpolate_constituents()</code></li> </ul> </li> <li><code>bilinear_interpolation()</code></li> <li><code>interpolate_data()</code></li> </ul> </li> <li>pybdy.tide.nemo_bdy_tide module<ul> <li><code>Extract</code><ul> <li><code>Extract.__init__()</code></li> <li><code>Extract.extract_con()</code></li> </ul> </li> </ul> </li> <li>pybdy.tide.nemo_bdy_tide3 module<ul> <li><code>constituents_index()</code></li> <li><code>nemo_bdy_tide_rot()</code></li> </ul> </li> <li>pybdy.tide.nemo_bdy_tide_ncgen module<ul> <li><code>CreateBDYTideNetcdfFile()</code></li> </ul> </li> <li>pybdy.tide.tpxo_extract_HC module<ul> <li><code>TpxoExtract</code><ul> <li><code>TpxoExtract.__init__()</code></li> <li><code>TpxoExtract.generate_landmask_from_bathymetry()</code></li> <li><code>TpxoExtract.interpolate_constituents()</code></li> </ul> </li> <li><code>bilinear_interpolation()</code></li> <li><code>interpolate_data()</code></li> </ul> </li> <li>Module contents</li> </ul> </li> <li>pybdy.utils package<ul> <li>Submodules</li> <li>pybdy.utils.Constants module</li> <li>pybdy.utils.e3_to_depth module<ul> <li><code>e3_to_depth()</code></li> </ul> </li> <li>pybdy.utils.gcoms_break_depth module<ul> <li><code>gcoms_boundary_masks()</code></li> <li><code>gcoms_break_depth()</code></li> <li><code>polcoms_select_domain()</code></li> </ul> </li> <li>pybdy.utils.nemo_bdy_lib module<ul> <li><code>bdy_sections()</code></li> <li><code>bdy_transport()</code></li> <li><code>dist()</code></li> <li><code>dist_point_to_segment()</code></li> <li><code>get_output_filename()</code></li> <li><code>get_output_tidal_filename()</code></li> <li><code>psi_field()</code></li> <li><code>rot_rep()</code></li> <li><code>sub2ind()</code></li> <li><code>velocity_field()</code></li> </ul> </li> <li>Module contents</li> </ul> </li> </ul>"},{"location":"pybdy/#submodules","title":"Submodules","text":""},{"location":"pybdy/#pybdynemo_bdy_chunk-module","title":"pybdy.nemo_bdy_chunk module","text":"<p>Created on Thu Dec 19 10:39:46 2024.</p> <p>@author James Harle @author Benjamin Barton</p>"},{"location":"pybdy/#pybdynemo_bdy_chunkchunk_bdybdy","title":"pybdy.nemo_bdy_chunk.chunk_bdy(bdy)","text":"<p>Master chunking function.</p> <p>Takes the boundary indicies and turns them into a list of boundary chunks. The boundary is first split at natural breaks like land or the east-west wrap. The chunks are then split near corners. The chunks are then optionally split in the middle if they\u2019re above a certain size after attempting to split at corners.</p>"},{"location":"pybdy/#parameters","title":"Parameters","text":"<p>bdy (obj) : organised as bdy_i[point, i/j grid] and rim width bdy_r[point] logger : log error and messages</p>"},{"location":"pybdy/#returns","title":"Returns","text":"<p>chunk_number (numpy.array) : array of chunk numbers</p>"},{"location":"pybdy/#pybdynemo_bdy_chunkchunk_corneribdy-jbdy-rbdy-chunk_number-rw","title":"pybdy.nemo_bdy_chunk.chunk_corner(ibdy, jbdy, rbdy, chunk_number, rw)","text":"<p>Find corners and split along the change in direction.</p> <p>To do this we look for a change in direction along each rim.</p>"},{"location":"pybdy/#parameters_1","title":"Parameters","text":"<p>ibdy (numpy.array) : index in i direction jbdy (numpy.array) : index in j direction rbdy (numpy.array) : rim index chunk_number (numpy.array) : array of chunk numbers. -1 means an unassigned chunk number rw (int) : rimwidth</p>"},{"location":"pybdy/#returns_1","title":"Returns","text":"<p>chunk_number (numpy.array) : array of chunk numbers</p>"},{"location":"pybdy/#pybdynemo_bdy_chunkchunk_landibdy-jbdy-chunk_number-rw","title":"pybdy.nemo_bdy_chunk.chunk_land(ibdy, jbdy, chunk_number, rw)","text":"<p>Find natural breaks in the boundary looking for gaps in i and j.</p>"},{"location":"pybdy/#parameters_2","title":"Parameters","text":"<p>ibdy (numpy.array) : index in i direction jbdy (numpy.array) : index in j direction chunk_number (numpy.array) : array of chunk numbers. -1 means an unassigned chunk number rw (int) : rimwidth</p>"},{"location":"pybdy/#returns_2","title":"Returns","text":"<p>chunk_number (numpy.array) : array of chunk numbers</p>"},{"location":"pybdy/#pybdynemo_bdy_chunkchunk_largeibdy-jbdy-chunk_number","title":"pybdy.nemo_bdy_chunk.chunk_large(ibdy, jbdy, chunk_number)","text":"<p>Split boundaries that have too much white space and are too large.</p>"},{"location":"pybdy/#parameters_3","title":"Parameters","text":"<p>ibdy (numpy.array) : index in i direction jbdy (numpy.array) : index in j direction chunk_number (numpy.array) : array of chunk numbers. -1 means an unassigned chunk number</p>"},{"location":"pybdy/#returns_3","title":"Returns","text":"<p>chunk_number (numpy.array) : array of chunk numbers</p>"},{"location":"pybdy/#pybdynemo_bdy_dst_coord-module","title":"pybdy.nemo_bdy_dst_coord module","text":""},{"location":"pybdy/#class-pybdynemo_bdy_dst_coorddstcoord","title":"class pybdy.nemo_bdy_dst_coord.DstCoord","text":"<p>Bases: <code>object</code></p> <p>Object is currently empty and has data bound to it externally.</p> <p>Equivalent to Matlab dst_coord.</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assist-module","title":"pybdy.nemo_bdy_extr_assist module","text":"<p>Created on Thu Dec 21 17:34:00 2024.</p> <p>@author James Harle @author Benjamin Barton</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistcheck_wrapimin-imax-sc_lon","title":"pybdy.nemo_bdy_extr_assist.check_wrap(imin, imax, sc_lon)","text":"<p>Check if source domain wraps and dst spans the wrap.</p>"},{"location":"pybdy/#parameters_4","title":"Parameters","text":"<p>imin (int) : minimum i index imax (int) : maximum i index sc_lon (np.array) : the longitude of the source grid</p>"},{"location":"pybdy/#returns_4","title":"Returns","text":"<p>wrap_flag (bool) : if true the sc wraps and dst spans wrap</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistdistance_weightssc_bdy-dist_tot-sc_z_len-r0-logger","title":"pybdy.nemo_bdy_extr_assist.distance_weights(sc_bdy, dist_tot, sc_z_len, r0, logger)","text":"<p>Find the distance weightings for averaging source data to destination.</p>"},{"location":"pybdy/#parameters_5","title":"Parameters","text":"<p>sc_bdy (numpy.array) : source data dist_tot (numpy.array) : distance from dst point to 9 nearest sc points sc_z_len (int) : the number of depth levels r0 (float) : correlation distance logger : log of statements</p>"},{"location":"pybdy/#returns_5","title":"Returns","text":"<p>dist_wei (numpy.array) : weightings for averaging dist_fac (numpy.array) : total weighting factor</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistflood_fillsc_bdy-isslab-logger","title":"pybdy.nemo_bdy_extr_assist.flood_fill(sc_bdy, isslab, logger)","text":"<p>Fill the data horizontally then downwards to remove nans before interpolation.</p>"},{"location":"pybdy/#parameters_6","title":"Parameters","text":"<p>sc_bdy (np.array) : souce data [nz_sc, nbdy, 9] isslab (bool) : if true data has vertical cells for vertical flood fill logger : log of statements</p>"},{"location":"pybdy/#returns_6","title":"Returns","text":"<p>sc_bdy (np.array) : souce data [nz_sc, nbdy, 9]</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistget_inddst_lon-dst_lat-sc_lon-sc_lat","title":"pybdy.nemo_bdy_extr_assist.get_ind(dst_lon, dst_lat, sc_lon, sc_lat)","text":"<p>Calculate indicies of max and min for data extraction.</p>"},{"location":"pybdy/#parameters_7","title":"Parameters","text":"<p>dst_lon (np.array) : the longitude of the destination grid dst_lat (np.array) : the latitude of the destination grid sc_lon (np.array) : the longitude of the source grid sc_lat (np.array) : the latitude of the source grid</p>"},{"location":"pybdy/#returns_7","title":"Returns","text":"<p>imin (int) : minimum i index imax (int) : maximum i index jmin (int) : minimum j index jmax (int) : maximum j index</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistget_vertical_weightsdst_dep-dst_len_z-num_bdy-sc_z-sc_z_len-ind-zco","title":"pybdy.nemo_bdy_extr_assist.get_vertical_weights(dst_dep, dst_len_z, num_bdy, sc_z, sc_z_len, ind, zco)","text":"<p>Determine 3D depth vertical weights for the linear interpolation onto Dst grid.</p> <p>Selects 9 source points horizontally around a destination grid point. Calculated the distance from each source point to the destination to be used in weightings. The resulting arrays are [nz * nbdy * 9, 2].</p>"},{"location":"pybdy/#parameters_8","title":"Parameters","text":"<p>dst_dep (np.array) : the depth of the destination grid chunk [nz, nbdy] dst_len_z (int) : the length of depth axis of the destination grid num_bdy (int) : number of boundary points in chunk sc_z (np.array) : the depth of the source grid [k, j, i] sc_z_len (int) : the length of depth axis of the source grid ind (np.array) : indices of bdy and 9 nearest neighbours flattened \u201cF\u201d j,i [nbdy, 9] zco (bool) : if True z levels are not spatially varying</p>"},{"location":"pybdy/#returns_8","title":"Returns","text":"<p>z9_dist (np.array) : the distance weights of the selected points z9_ind (np.array) : the indices of the sc depth above and below bdy</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistget_vertical_weights_zcodst_dep-dst_len_z-num_bdy-sc_z-sc_z_len","title":"pybdy.nemo_bdy_extr_assist.get_vertical_weights_zco(dst_dep, dst_len_z, num_bdy, sc_z, sc_z_len)","text":"<p>Determine vertical weights for the linear interpolation onto Dst grid.</p> <p>Calculated the vertical distance from each source point to the destination to be used in weightings. The resulting arrays are [nbdy * nz, 2].</p> <p>Note: z_dist and z_ind are [nbdy*nz, 2] where [:, 0] is the nearest vertical index and [:, 1] is the index above or below i.e. the vertical index -1 for sc_z &gt; dst_z and vertical index +1 for sc_z \\&lt;= dst_z</p>"},{"location":"pybdy/#parameters_9","title":"Parameters","text":"<p>dst_dep (np.array) : the depth of the destination grid chunk [nz, nbdy] dst_len_z (int) : the length of depth axis of the destination grid num_bdy (int) : number of boundary points in chunk sc_z (np.array) : the depth of the source grid [k, j, i] sc_z_len (int) : the length of depth axis of the source grid</p>"},{"location":"pybdy/#returns_9","title":"Returns","text":"<p>z_dist (np.array) : the distance weights of the selected points z_ind (np.array) : the indices of the sc depth above and below bdy</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistinterp_horizontalsc_bdy-dist_wei-dist_fac-logger","title":"pybdy.nemo_bdy_extr_assist.interp_horizontal(sc_bdy, dist_wei, dist_fac, logger)","text":"<p>Interpolate the source data to the destination grid using weighted average.</p>"},{"location":"pybdy/#parameters_10","title":"Parameters","text":"<p>sc_bdy (numpy.array) : source data dist_wei (numpy.array) : weightings for interpolation dist_fac (numpy.array) : sum of weightings logger : log of statements</p>"},{"location":"pybdy/#returns_10","title":"Returns","text":"<p>dst_bdy (numpy.array) : destination bdy points with data from source grid</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistinterp_verticalsc_bdy-dst_dep-bdy_bathy-z_ind-z_dist-num_bdy-zinterptrue","title":"pybdy.nemo_bdy_extr_assist.interp_vertical(sc_bdy, dst_dep, bdy_bathy, z_ind, z_dist, num_bdy, zinterp=True)","text":"<p>Interpolate source data onto destination vertical levels.</p>"},{"location":"pybdy/#parameters_11","title":"Parameters","text":"<p>sc_bdy (np.array) : souce data [nz_sc, nbdy, 9] dst_dep (np.array) : the depth of the destination grid chunk [nz, nbdy] bdy_bathy (np.array): the destination grid bdy points bathymetry z_ind (np.array) : the indices of the sc depth above and below bdy point z_dist (np.array) : the distance weights of the selected points num_bdy (int) : number of boundary points in chunk zinterp (bool) : vertical interpolation flag</p>"},{"location":"pybdy/#returns_11","title":"Returns","text":"<p>data_out (np.array) : source data on destination depth levels</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_assistvalid_indexsc_bdy-logger","title":"pybdy.nemo_bdy_extr_assist.valid_index(sc_bdy, logger)","text":"<p>Find an array of valid indicies.</p>"},{"location":"pybdy/#parameters_12","title":"Parameters","text":"<p>sc_bdy (numpy.array) : source data logger : log of statements</p>"},{"location":"pybdy/#returns_12","title":"Returns","text":"<p>data_ind (numpy.array) : indicies of max depth of valid data nan_ind (numpy.array) : indicies where source is land</p>"},{"location":"pybdy/#pybdynemo_bdy_extr_tm3-module","title":"pybdy.nemo_bdy_extr_tm3 module","text":"<p>Created on Wed Sep 12 08:02:46 2012.</p> <p>This Module defines the extraction of the data from the source grid and does the interpolation onto the destination grid.</p> <p>@author James Harle @author John Kazimierz Farey</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy/#class-pybdynemo_bdy_extr_tm3extractsetup-sourcecoord-dstcoord-grid-var_nam-grd-pair","title":"class pybdy.nemo_bdy_extr_tm3.Extract(setup, SourceCoord, DstCoord, Grid, var_nam, grd, pair)","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy/#method-__init__setup-sourcecoord-dstcoord-grid-var_nam-grd-pair","title":"method __init__(setup, SourceCoord, DstCoord, Grid, var_nam, grd, pair)","text":"<p>Initialise the Extract object.</p> <p>Parent grid to child grid weights are defined along with rotation weightings for vector quantities.</p>"},{"location":"pybdy/#parameters_13","title":"Parameters","text":"<p>setup (list) : settings for bdy SourceCoord (obj) : source grid information DstCoord (obj) : destination grid information Grid (dict) : containing grid type \u2018t\u2019, \u2018u\u2019, \u2018v\u2019 and source time var_name (list) : netcdf file variable names (str) grd (str) : grid to process \u2018t\u2019, \u2018u\u2019, \u2018v\u2019 pair (str) : None or \u2018uv\u2019</p>"},{"location":"pybdy/#returns_13","title":"Returns","text":"<p>Extract (obj) : Object with indexing arrays and weightings ready for interpolation</p>"},{"location":"pybdy/#method-cal_transsource-dest-year-month","title":"method cal_trans(source, dest, year, month)","text":"<p>Translate between calendars and return scale factor and number of days in month.</p>"},{"location":"pybdy/#parameters_14","title":"Parameters","text":"<p>source : source calendar dest : destination calendar year : input year month : input month</p>"},{"location":"pybdy/#returns_14","title":"Returns","text":"<p>sf : scale factor ed : number of days in month</p>"},{"location":"pybdy/#method-extract_monthyear-month","title":"method extract_month(year, month)","text":"<p>Extract monthly data and interpolates onto the destination grid.</p>"},{"location":"pybdy/#parameters_15","title":"Parameters","text":"<p>year : year of data to be extracted month : month of the year to be extracted</p>"},{"location":"pybdy/#returns_15","title":"Returns","text":"<p>self.data_out : data from source on bdy locations and depths</p>"},{"location":"pybdy/#method-time_deltatime_counter","title":"method time_delta(time_counter)","text":"<p>Get time delta and number of time steps per day.</p> <p>Calculates difference between time steps for time_counter and checks these are uniform. Then retrives the number of time steps per day.</p>"},{"location":"pybdy/#parameters_16","title":"Parameters","text":"<p>time_counter : model time coordinate</p>"},{"location":"pybdy/#returns_16","title":"Returns","text":"<p>deltaT : length of time step dstep : number of time steps per day</p>"},{"location":"pybdy/#method-time_interpyear-month","title":"method time_interp(year, month)","text":"<p>Perform a time interpolation of the BDY data to daily frequency.</p> <p>This method performs a time interpolation (if required). This is necessary if the time frequency is not a factor of monthly output or the input and output calendars differ. CF compliant calendar options</p> <p>accepted: gregorian | standard, proleptic_gregorian, noleap | 365_day, 360_day or julian.*</p>"},{"location":"pybdy/#method-write_outyear-month-ind-unit_origin","title":"method write_out(year, month, ind, unit_origin)","text":"<p>Write monthy BDY data to netCDF file.</p> <p>This method writes out all available variables for a given grid along with any asscoaied metadata. Currently data are only written out as monthly files.</p>"},{"location":"pybdy/#parameters_17","title":"Parameters","text":"<p>year (int) : year to write out month (int) : month to write out ind (dict): dictionary holding grid information unit_origin (str) : time reference \u2018%d 00:00:00\u2019 %date_origin</p>"},{"location":"pybdy/#returns_17","title":"Returns","text":"<p>None</p>"},{"location":"pybdy/#pybdynemo_bdy_gen_c-module","title":"pybdy.nemo_bdy_gen_c module","text":"<p>NEMO Boundary module.</p> <p>Creates indices for t, u and v points, plus rim gradient. The variable names have been renamed to keep consistent with python standards and generalizing the variable names eg. bdy_i is used instead of bdy_t</p> <p>Ported from Matlab code by James Harle</p> <p>@author: John Kazimierz Farey @author: Srikanth Nagella.</p>"},{"location":"pybdy/#class-pybdynemo_bdy_gen_cboundaryboundary_mask-settings-grid","title":"class pybdy.nemo_bdy_gen_c.Boundary(boundary_mask, settings, grid)","text":"<p>Bases: <code>object</code></p> <p>Class for boundary definitions.</p>"},{"location":"pybdy/#method-__init__boundary_mask-settings-grid","title":"method __init__(boundary_mask, settings, grid)","text":"<p>Generate the indices for NEMO Boundary and returns a Grid object with indices.</p>"},{"location":"pybdy/#parameters_18","title":"Parameters","text":"<p>boundary_mask : boundary mask settings : dictionary of setting values grid : type of the grid \u2018t\u2019, \u2018u\u2019, \u2018v\u2019</p>"},{"location":"pybdy/#returns_18","title":"Returns","text":"<p>Boundary (object) : where bdy_i is index and bdy_r is the r index</p>"},{"location":"pybdy/#method-fillmask-ref-brg","title":"method fill(mask, ref, brg)","text":""},{"location":"pybdy/#method-find_bdyigrid-jgrid-mask-brg","title":"method find_bdy(igrid, jgrid, mask, brg)","text":"<p>Find the border indexes by checking the change from ocean to land.</p> <p>Returns the i and j index array where the shift happens.</p>"},{"location":"pybdy/#parameters_19","title":"Parameters","text":"<p>igrid : I x direction indexes jgrid : J y direction indexes mask : mask data brg : mask index range</p>"},{"location":"pybdy/#returns_19","title":"Returns","text":"<p>bdy_i : bdy indexes bdy_r : bdy rim values.</p>"},{"location":"pybdy/#method-remove_duplicate_pointsbdy_i-bdy_r","title":"method remove_duplicate_points(bdy_i, bdy_r)","text":"<p>Remove the duplicate points in the bdy_i and return the bdy_i and bdy_r.</p>"},{"location":"pybdy/#parameters_20","title":"Parameters","text":"<p>bdy_i : bdy indexes bdy_r : bdy rim values.</p>"},{"location":"pybdy/#returns_20","title":"Returns","text":"<p>bdy_i : bdy indexes bdy_r : bdy rim values.</p>"},{"location":"pybdy/#method-remove_landpoints_open_oceanmask-bdy_i-bdy_r","title":"method remove_landpoints_open_ocean(mask, bdy_i, bdy_r)","text":"<p>Remove the land points and open ocean points.</p>"},{"location":"pybdy/#method-unique_rowst","title":"method unique_rows(t)","text":"<p>Find indexes of unique rows in the input 2D array.</p>"},{"location":"pybdy/#parameters_21","title":"Parameters","text":"<p>t : input 2D array.</p>"},{"location":"pybdy/#returns_21","title":"Returns","text":"<p>indx : indexes of unique rows</p>"},{"location":"pybdy/#pybdynemo_bdy_grid_angle-module","title":"pybdy.nemo_bdy_grid_angle module","text":""},{"location":"pybdy/#class-pybdynemo_bdy_grid_anglegridanglehgr-imin-imax-jmin-jmax-cd_type","title":"class pybdy.nemo_bdy_grid_angle.GridAngle(hgr, imin, imax, jmin, jmax, cd_type)","text":"<p>Bases: <code>object</code></p> <p>Class to get orientation of grid from I and J offsets for different grid types.</p>"},{"location":"pybdy/#method-__init__hgr-imin-imax-jmin-jmax-cd_type","title":"method __init__(hgr, imin, imax, jmin, jmax, cd_type)","text":"<p>Get sin and cosin files for the grid angle from North.</p>"},{"location":"pybdy/#parameters_22","title":"Parameters","text":"<p>hgr : grid object imin : minimum model zonal indices imax : maximum model zonal indices jmin : minimum model meridional indices jmax : maximum model meridional indices cd_type: define the nature of pt2d grid points</p>"},{"location":"pybdy/#returns_22","title":"Returns","text":"<p>None : object</p>"},{"location":"pybdy/#method-get_lam_phimapfalse-i0-j0-singlefalse","title":"method get_lam_phi(map=False, i=0, j=0, single=False)","text":"<p>Get lam/phi in (offset) i/j range for init grid type.</p> <p>Data must be converted to float64 to prevent dementation of later results.</p>"},{"location":"pybdy/#method-get_north_dir","title":"method get_north_dir()","text":"<p>Find North pole direction and modulus of some point.</p>"},{"location":"pybdy/#method-get_seg_dirnorth_n","title":"method get_seg_dir(north_n)","text":"<p>Find segmentation direction of some point.</p>"},{"location":"pybdy/#method-get_sin_cosnx-ny-nn-sx-sy-sn","title":"method get_sin_cos(nx, ny, nn, sx, sy, sn)","text":"<p>Get sin and cos from lat and lon using using scaler/vectorial products.</p>"},{"location":"pybdy/#method-trig_eqx-eq-z_one-z_two","title":"method trig_eq(x, eq, z_one, z_two)","text":"<p>Calculate long winded equation of two vars; some lam and phi.</p>"},{"location":"pybdy/#pybdynemo_bdy_ice-module","title":"pybdy.nemo_bdy_ice module","text":""},{"location":"pybdy/#class-pybdynemo_bdy_iceboundaryice","title":"class pybdy.nemo_bdy_ice.BoundaryIce","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy/#method-__init__","title":"method __init__()","text":""},{"location":"pybdy/#pybdynemo_bdy_ncgen-module","title":"pybdy.nemo_bdy_ncgen module","text":"<p>Create a Nemo Bdy netCDF file ready for population.</p> <p>Written by John Kazimierz Farey, started August 30, 2012 Port of Matlab code of James Harle</p>"},{"location":"pybdy/#pybdynemo_bdy_ncgencreatebdynetcdffilefilename-xb_len-x_len-y_len-depth_len-rw-h-orig-fv-calendar-grd","title":"pybdy.nemo_bdy_ncgen.CreateBDYNetcdfFile(filename, xb_len, x_len, y_len, depth_len, rw, h, orig, fv, calendar, grd)","text":"<p>Create a template of bdy netcdf files. A common for T, I, U, V, E grid types.</p>"},{"location":"pybdy/#pybdynemo_bdy_ncpop-module","title":"pybdy.nemo_bdy_ncpop module","text":"<p>Created on 3 Oct 2014.</p> <p>@author: Mr. Srikanth Nagella Netcdf writer for the bdy output</p>"},{"location":"pybdy/#pybdynemo_bdy_ncpopwrite_data_to_filefilename-variable_name-data","title":"pybdy.nemo_bdy_ncpop.write_data_to_file(filename, variable_name, data)","text":"<p>Write the data to the netcdf templete file.</p> <p>filename \u2013 output filename variable_name \u2013 variable name into which the data is written to. data \u2013 data that will be written to variable in netcdf.</p>"},{"location":"pybdy/#parameters_23","title":"Parameters","text":""},{"location":"pybdy/#pybdynemo_bdy_scr_coord-module","title":"pybdy.nemo_bdy_scr_coord module","text":""},{"location":"pybdy/#class-pybdynemo_bdy_scr_coordscrcoord","title":"class pybdy.nemo_bdy_scr_coord.ScrCoord","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy/#method-__init___1","title":"method __init__()","text":""},{"location":"pybdy/#pybdynemo_bdy_setup-module","title":"pybdy.nemo_bdy_setup module","text":"<p>Created on Wed Sep 12 08:02:46 2012.</p> <p>Parses a file to find out which nemo boundary settings to use</p> <p>@author John Kazimierz Farey @author James Harle</p>"},{"location":"pybdy/#class-pybdynemo_bdy_setupsetupsetfile","title":"class pybdy.nemo_bdy_setup.Setup(setfile)","text":"<p>Bases: <code>object</code></p> <p>Invoke with a text file location, class init reads and deciphers variables.</p> <p>This class holds the settings information</p>"},{"location":"pybdy/#method-__init__setfile","title":"method __init__(setfile)","text":"<p>Set up the constructor.</p> <p>This constructor reads the settings file and sets the dictionary with setting name/key and it\u2019s value.</p>"},{"location":"pybdy/#parameters_24","title":"Parameters","text":"<p>setfile (str) : settings file</p>"},{"location":"pybdy/#method-refresh","title":"method refresh()","text":"<p>Reload the settings from file.</p>"},{"location":"pybdy/#method-variable_info_readerfilename","title":"method variable_info_reader(filename)","text":"<p>Read the variable description data from the \u2018variable.info\u2019 file.</p> <p>This method reads the variable description data from \u2018variable.info\u2019 file in the pybdy installation path if it can\u2019t find the file with the same name as input bdy file with extension .info</p> <p>filename \u2013 filename of the variables information returns a dictionary with variable name and its description.</p>"},{"location":"pybdy/#parameters_25","title":"Parameters","text":""},{"location":"pybdy/#returns_23","title":"Returns","text":"<p>variable_info : dict</p>"},{"location":"pybdy/#method-write","title":"method write()","text":"<p>Write backs the variable data back into the file.</p>"},{"location":"pybdy/#pybdynemo_bdy_setupstrip_commentsline","title":"pybdy.nemo_bdy_setup.strip_comments(line)","text":"<p>Strip the comments in the line. removes text after !.</p>"},{"location":"pybdy/#pybdynemo_bdy_source_coord-module","title":"pybdy.nemo_bdy_source_coord module","text":""},{"location":"pybdy/#class-pybdynemo_bdy_source_coordsourcecoord","title":"class pybdy.nemo_bdy_source_coord.SourceCoord","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy/#method-__init___2","title":"method __init__()","text":"<p>Initialise the source coordinates attributes of the object.</p>"},{"location":"pybdy/#pybdynemo_bdy_zgrv2-module","title":"pybdy.nemo_bdy_zgrv2 module","text":"<p>Created.</p> <p>@author John Kazimierz Farey @author Benjamin Barton.</p>"},{"location":"pybdy/#pybdynemo_bdy_zgrv2get_bdy_depthsdstcoord-bdy_i-grd","title":"pybdy.nemo_bdy_zgrv2.get_bdy_depths(DstCoord, bdy_i, grd)","text":"<p>Depth levels on the destination grid at bdy points.</p>"},{"location":"pybdy/#parameters_26","title":"Parameters","text":"<p>DstCoord (object) : Object containing destination grid info bdy_i (np.array) : indices of the i, j bdy points [bdy, 2] grd (str) : grid type t, u, v</p>"},{"location":"pybdy/#returns_24","title":"Returns","text":"<p>bdy_tz (array) : sc depths on bdy points on t levels bdy_wz (array) : sc depths on bdy points on w levels bdy_e3 (array) : sc level thickness on bdy points on t levels</p>"},{"location":"pybdy/#pybdynemo_bdy_zgrv2get_bdy_depths_oldbdy_t-bdy_u-bdy_v-dstcoord-settings","title":"pybdy.nemo_bdy_zgrv2.get_bdy_depths_old(bdy_t, bdy_u, bdy_v, DstCoord, settings)","text":"<p>Generate Depth information.</p> <p>Written by John Kazimierz Farey, Sep 2012 Port of Matlab code of James Harle</p> <p>Generates depth points for t, u and v in one loop iteration. Initialise with bdy t, u and v grid attributes (Grid.bdy_i) and settings dictionary.</p>"},{"location":"pybdy/#pybdynemo_bdy_zgrv2get_bdy_sc_depthssourcecoord-dstcoord-grd","title":"pybdy.nemo_bdy_zgrv2.get_bdy_sc_depths(SourceCoord, DstCoord, grd)","text":"<p>Depth levels from the nearest neighbour on the source grid.</p>"},{"location":"pybdy/#parameters_27","title":"Parameters","text":"<p>SourceCoord (object) : Object containing source grid info DstCoord (object) : Object containing destination grid info grd (str) : grid type t, u, v</p>"},{"location":"pybdy/#returns_25","title":"Returns","text":"<p>bdy_tz (array) : sc depths on bdy points on t levels bdy_wz (array) : sc depths on bdy points on w levels bdy_e3 (array) : sc level thickness on bdy points on t levels</p>"},{"location":"pybdy/#pybdynemo_coord_gen_pop-module","title":"pybdy.nemo_coord_gen_pop module","text":"<p>Module that combines matlab coord gen and pop.</p> <p>Initialise with netcdf file name and dictionary containing all bdy grids (objects).</p>"},{"location":"pybdy/#class-pybdynemo_coord_gen_popcoordfname-bdy_ind","title":"class pybdy.nemo_coord_gen_pop.Coord(fname, bdy_ind)","text":"<p>Bases: <code>object</code></p> <p>Class for writing boundayr coordinate data to netcdf file.</p>"},{"location":"pybdy/#method-__init__fname-bdy_ind","title":"method __init__(fname, bdy_ind)","text":"<p>Create Nemo bdy indices for t, u, v points.</p>"},{"location":"pybdy/#parameters_28","title":"Parameters","text":"<p>fname (str) : file name of coords file for output bdy_ind (numpy.array) : indicies of bdy points</p>"},{"location":"pybdy/#returns_26","title":"Returns","text":"<p>None : object</p>"},{"location":"pybdy/#method-add_varsdim-grd-unt","title":"method add_vars(dim, grd, unt)","text":"<p>Create a var w/ attributes.</p>"},{"location":"pybdy/#method-build_dictdim-units","title":"method build_dict(dim, units)","text":"<p>Set up a grid dictionary.</p>"},{"location":"pybdy/#method-closeme","title":"method closeme()","text":""},{"location":"pybdy/#method-create_dims","title":"method create_dims()","text":"<p>Create dims and returns a dictionary of them.</p>"},{"location":"pybdy/#method-populatehgr","title":"method populate(hgr)","text":"<p>Populate the file with indices, lat, lon, and e dimensions.</p>"},{"location":"pybdy/#method-set_lenvarvardic-hgrnone-untnone","title":"method set_lenvar(vardic, hgr=None, unt=None)","text":"<p>Set the len var of each array in the var dictionary.</p> <p>Use by specifying hgr and unt which pulls data from loaded grid data. Otherwise pull it from the class dict.</p>"},{"location":"pybdy/#pybdyprofiler-module","title":"pybdy.profiler module","text":"<p>Created on Wed Sep 12 08:02:46 2012.</p> <p>The main application script for the NRCT.</p> <p>@author James Harle @author John Kazimierz Farey @author Srikanth Nagella</p>"},{"location":"pybdy/#class-pybdyprofilergrid","title":"class pybdy.profiler.Grid","text":"<p>Bases: <code>object</code></p> <p>A Grid object that stores bdy grid information.</p>"},{"location":"pybdy/#method-__init___3","title":"method __init__()","text":""},{"location":"pybdy/#pybdyprofilerprocess_bdysetup_filepath0-mask_guifalse","title":"pybdy.profiler.process_bdy(setup_filepath=0, mask_gui=False)","text":"<p>Handle all the calls to generate open boundary conditions for a given regional domain.</p> <p>This is main entry for processing BDY lateral boundary conditions. This is the main script that handles all the calls to generate open boundary conditions for a given regional domain. Input options are handled in a NEMO style namelist (namelist.bdy). There is an optional GUI allowing the user to create a mask that defines the extent of the regional model.</p>"},{"location":"pybdy/#parameters_29","title":"Parameters","text":"<p>setup_filepath (str) : file path to find namelist.bdy mask_gui (bool): whether use of the GUI is required</p>"},{"location":"pybdy/#returns_27","title":"Returns","text":"<p>None : bdy data is written out to NetCDF file</p>"},{"location":"pybdy/#pybdyprofilerwrite_tidal_datasetup_var-dst_coord_var-grid-tide_cons-cons","title":"pybdy.profiler.write_tidal_data(setup_var, dst_coord_var, grid, tide_cons, cons)","text":"<p>Write the tidal data to a NetCDF file.</p>"},{"location":"pybdy/#parameters_30","title":"Parameters","text":"<p>setup_var (list): Description of arg1 dst_coord_var (obj) : Description of arg1 grid (dict): Description of arg1 tide_cons (list): Description of arg1 cons (data): cosz, sinz, cosu, sinu, cosv, sinv</p>"},{"location":"pybdy/#returns_28","title":"Returns","text":"<p>None : tidal data is written to NetCDF file</p>"},{"location":"pybdy/#pybdypybdy_exe-module","title":"pybdy.pybdy_exe module","text":"<p>Entry for the project.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy/#pybdypybdy_exemain","title":"pybdy.pybdy_exe.main()","text":"<p>Run main function.</p> <p>Checks the command line parameters and passes them to the profile module for processing.</p>"},{"location":"pybdy/#pybdypybdy_ncml_generator-module","title":"pybdy.pybdy_ncml_generator module","text":"<p>Created on 2 Jul 2015.</p> <p>The main application object for hosting the pybdy ncml editor. Used for development purposes to display the ncml editor dialog.</p> <p>@author: Shirley Crompton, UK Science and Technology Facilities Council</p>"},{"location":"pybdy/#pybdypybdy_ncml_generatormain","title":"pybdy.pybdy_ncml_generator.main()","text":"<p>Command line execution method.</p> <p>Checks the input arguments and passes on to method to open the ncml generator window.</p>"},{"location":"pybdy/#pybdypybdy_settings_editor-module","title":"pybdy.pybdy_settings_editor module","text":"<p>Created on 7 Jan 2015.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy/#pybdypybdy_settings_editormain","title":"pybdy.pybdy_settings_editor.main()","text":"<p>Command line execution method.</p> <p>Checks the input arguments and passes on to method to open the settings window.</p>"},{"location":"pybdy/#pybdypybdy_settings_editoropen_settings_dialogsetup","title":"pybdy.pybdy_settings_editor.open_settings_dialog(setup)","text":"<p>Start the settings window using the setup settings provided in the input.</p> <p>On clicking the cancel button it doesn\u2019t shutdown the applicaiton but carries on with the execution.</p>"},{"location":"pybdy/#pybdypybdy_settings_editoropen_settings_windowfname","title":"pybdy.pybdy_settings_editor.open_settings_window(fname)","text":"<p>Start a Qt application.</p> <p>This method gives the user the option to pick a namelist.bdy file to edit. Once user selects it it will open a dialog box where users can edit the parameters.</p>"},{"location":"pybdy/#pybdyversion-module","title":"pybdy.version module","text":""},{"location":"pybdy/#module-contents","title":"Module contents","text":"<p>a Python based regional NEMO model configuration toolbox.</p>"},{"location":"pybdy.reader/","title":"pybdy.reader package","text":""},{"location":"pybdy.reader/#pybdyreader-package","title":"pybdy.reader package","text":""},{"location":"pybdy.reader/#submodules","title":"Submodules","text":""},{"location":"pybdy.reader/#pybdyreaderdirectory-module","title":"pybdy.reader.directory module","text":"<p>Abstraction for the data repository.</p> <p>@author: Mr. Srikanth Nagella.</p>"},{"location":"pybdy.reader/#class-pybdyreaderdirectorygridgroup","title":"class pybdy.reader.directory.GridGroup","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy.reader/#method-__init__","title":"method __init__()","text":""},{"location":"pybdy.reader/#method-get_meta_datavariable-source_dic","title":"method get_meta_data(variable, source_dic)","text":"<p>Return a dictionary with meta data information correspoinding to the variable.</p>"},{"location":"pybdy.reader/#class-pybdyreaderdirectoryreaderdirectory-time_adjust","title":"class pybdy.reader.directory.Reader(directory, time_adjust)","text":"<p>Bases: <code>object</code></p> <p>Reader for all the files in the directory as one single object.</p>"},{"location":"pybdy.reader/#examples","title":"Examples","text":"<p>reader = Reader(\u201cFolder path\u201d)</p> <p>reader[\u201ct\u201d][\u201cvotemper\u201d][:, :, :, :]</p>"},{"location":"pybdy.reader/#method-__init__directory-time_adjust","title":"method __init__(directory, time_adjust)","text":"<p>Take in directory path as input and return the required information to the bdy.</p>"},{"location":"pybdy.reader/#parameters","title":"Parameters","text":"<p>directory : The directory in which to look for the files time_adjust : amount of time to be adjusted to the time read from file.</p>"},{"location":"pybdy.reader/#returns","title":"Returns","text":"<p>None : object</p>"},{"location":"pybdy.reader/#method-calculate_time_interval","title":"method calculate_time_interval()","text":"<p>Calculate the time interval of the each grid.</p> <p>If all the grids get the same interval then it sets it to the days and hours. Otherwise it throws an error.</p>"},{"location":"pybdy.reader/#method-delta_time_intervaltime1-time2","title":"method delta_time_interval(time1, time2)","text":"<p>Get the difference between the two times in days and hours.</p>"},{"location":"pybdy.reader/#method-get_dir_listgrid","title":"method get_dir_list(grid)","text":"<p>Scan the directory for a input grid related NetCDF files (i.e., ending with the grid name.</p>"},{"location":"pybdy.reader/#parameters_1","title":"Parameters","text":"<p>grid (str) : grid name eg. \u2018t\u2019,\u2019v\u2019,\u2019u\u2019,\u2019i\u2019.</p>"},{"location":"pybdy.reader/#returns_1","title":"Returns","text":"<p>dir_list (list) : list of files</p>"},{"location":"pybdy.reader/#method-get_source_timedatagrid-t_adjust","title":"method get_source_timedata(grid, t_adjust)","text":"<p>Get the source time data information.</p> <p>Builds up sourcedata objects of a given grid.</p>"},{"location":"pybdy.reader/#method-grid_type_list-t-u-v-i","title":"method grid_type_list = ['t', 'u', 'v', 'i']","text":""},{"location":"pybdy.reader/#class-pybdyreaderdirectoryvariablefilenames-variable","title":"class pybdy.reader.directory.Variable(filenames, variable)","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy.reader/#method-__init__filenames-variable","title":"method __init__(filenames, variable)","text":""},{"location":"pybdy.reader/#method-get_attribute_valuesattr_name","title":"method get_attribute_values(attr_name)","text":"<p>Return the attribute value of the variable.</p>"},{"location":"pybdy.reader/#method-get_dimensions","title":"method get_dimensions()","text":"<p>Return the dimensions of the variables.</p>"},{"location":"pybdy.reader/#method-set_time_dimension_index","title":"method set_time_dimension_index()","text":"<p>Set the time dimension index.</p>"},{"location":"pybdy.reader/#method-time_counter_const-time_counter","title":"method time_counter_const = 'time_counter'","text":""},{"location":"pybdy.reader/#pybdyreaderfactory-module","title":"pybdy.reader.factory module","text":"<p>Generic file loader factory.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.reader/#pybdyreaderfactorygetfileuri","title":"pybdy.reader.factory.GetFile(uri)","text":""},{"location":"pybdy.reader/#pybdyreaderfactorygetreaderuri-t_adjust-reader_typenone","title":"pybdy.reader.factory.GetReader(uri, t_adjust, reader_type=None)","text":""},{"location":"pybdy.reader/#class-pybdyreaderfactorynetcdffilefilename","title":"class pybdy.reader.factory.NetCDFFile(filename)","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy.reader/#method-__init__filename","title":"method __init__(filename)","text":""},{"location":"pybdy.reader/#method-close","title":"method close()","text":""},{"location":"pybdy.reader/#pybdyreaderncml-module","title":"pybdy.reader.ncml module","text":"<p>NcML reading implementation using pyjnius.</p> <p>@author: Mr. Srikanth Nagella.</p>"},{"location":"pybdy.reader/#class-pybdyreaderncmlgridgroupfilename-dataset","title":"class pybdy.reader.ncml.GridGroup(filename, dataset)","text":"<p>Bases: <code>object</code></p> <p>Class that provides an indirection to the grid type.</p> <p>Since ncml file has aggregation of all the variables this is just a place holder.</p>"},{"location":"pybdy.reader/#method-__init__filename-dataset","title":"method __init__(filename, dataset)","text":"<p>Source data that holds the dataset information.</p>"},{"location":"pybdy.reader/#method-get_meta_datavariable-source_dic_1","title":"method get_meta_data(variable, source_dic)","text":"<p>Return a dictionary with meta data information correspoinding to the variable.</p>"},{"location":"pybdy.reader/#method-logger","title":"method logger = \\","text":""},{"location":"pybdy.reader/#method-update_atrributes","title":"method update_atrributes()","text":"<p>Update the units and calendar information for the grid.</p>"},{"location":"pybdy.reader/#class-pybdyreaderncmlncmlfilefilename","title":"class pybdy.reader.ncml.NcMLFile(filename)","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy.reader/#method-__init__filename_1","title":"method __init__(filename)","text":""},{"location":"pybdy.reader/#method-close_1","title":"method close()","text":""},{"location":"pybdy.reader/#class-pybdyreaderncmlreaderuri-time_adjust","title":"class pybdy.reader.ncml.Reader(uri, time_adjust)","text":"<p>Bases: <code>object</code></p> <p>High level object for the NCML reader, from here using grid type will return the grid data.</p>"},{"location":"pybdy.reader/#examples_1","title":"Examples","text":"<p>reader = Reader(\u201cNCML Filename\u201d)</p> <p>reader[\u201ct\u201d][\u201cvotemper\u201d][:, :, :, :]</p>"},{"location":"pybdy.reader/#method-__init__uri-time_adjust","title":"method __init__(uri, time_adjust)","text":""},{"location":"pybdy.reader/#method-close_2","title":"method close()","text":"<p>Not yet implemented.</p>"},{"location":"pybdy.reader/#method-grid_type_list-t-u-v-i_1","title":"method grid_type_list = ['t', 'u', 'v', 'i']","text":""},{"location":"pybdy.reader/#method-time_counter-time_counter","title":"method time_counter = 'time_counter'","text":""},{"location":"pybdy.reader/#class-pybdyreaderncmlvariabledataset-variable","title":"class pybdy.reader.ncml.Variable(dataset, variable)","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy.reader/#method-__init__dataset-variable","title":"method __init__(dataset, variable)","text":""},{"location":"pybdy.reader/#method-get_attribute_valueattr_name","title":"method get_attribute_value(attr_name)","text":"<p>Return the attribute value of the variable.</p>"},{"location":"pybdy.reader/#pybdyreaderncmlinit_jnius","title":"pybdy.reader.ncml.init_jnius()","text":""},{"location":"pybdy.reader/#module-contents","title":"Module contents","text":""},{"location":"pybdy.tide/","title":"pybdy.tide package","text":""},{"location":"pybdy.tide/#pybdytide-package","title":"pybdy.tide package","text":""},{"location":"pybdy.tide/#submodules","title":"Submodules","text":""},{"location":"pybdy.tide/#pybdytidefes2014_extract_hc-module","title":"pybdy.tide.fes2014_extract_HC module","text":"<p>Fes extraction of harmonic constituents.</p> <p>Extract the tidal harmonic constants out of a tidal model for a given locations [amp,gph] = fes2014_extract_HC(Model,lat,lon,type,Cid).</p> <p>Modified from tpxo_extract_HC.py</p> <p>3 Nov 2017 jelt</p>"},{"location":"pybdy.tide/#class-pybdytidefes2014_extract_hcfesextractsettings-lat-lon-grid_type","title":"class pybdy.tide.fes2014_extract_HC.FesExtract(settings, lat, lon, grid_type)","text":"<p>Bases: <code>object</code></p> <p>FES model extract of harmonic constituents.</p> <p>The source FES data are stored in one-file-per-constituent Note the FES data are structured with lat and lon reversed relative to TPXO I.e. FES(lat,lon) c.f. TPXO7(con,lon,lat). c.f. TPXO9(lon,lat)</p> <p>Note the FES heights are in cm (need to convert to metres) The momentum vector quantities are depth integrated TRANSPORTS (m^2/s). In TPXO7 both transport (m^2/s) and velocies (cm/s) are given. In TPXO9 only transport (cm^2/s) are given. Here we use the transport fluxes.</p>"},{"location":"pybdy.tide/#method-__init__settings-lat-lon-grid_type","title":"method __init__(settings, lat, lon, grid_type)","text":"<p>Initialise the Extract of tide information from the netcdf Tidal files.</p>"},{"location":"pybdy.tide/#method-interpolate_constituentsamp_fes-pha_fes-lon_fes-lat_fes-lon-lat","title":"method interpolate_constituents(amp_fes, pha_fes, lon_fes, lat_fes, lon, lat)","text":"<p>Interpolates the tidal constituents along the given lat lon coordinates.</p>"},{"location":"pybdy.tide/#pybdytidefes2014_extract_hcbilinear_interpolationlon-lat-data-lon_new-lat_new","title":"pybdy.tide.fes2014_extract_HC.bilinear_interpolation(lon, lat, data, lon_new, lat_new)","text":"<p>Perform a bilinear interpolation of grid where the data values are NaN\u2019s.</p>"},{"location":"pybdy.tide/#pybdytidefes2014_extract_hcinterpolate_datalon-lat-data-mask-lonlat","title":"pybdy.tide.fes2014_extract_HC.interpolate_data(lon, lat, data, mask, lonlat)","text":"<p>Interpolate data data on regular grid for given lonlat coordinates.</p>"},{"location":"pybdy.tide/#pybdytidenemo_bdy_tide-module","title":"pybdy.tide.nemo_bdy_tide module","text":""},{"location":"pybdy.tide/#class-pybdytidenemo_bdy_tideextractsetup-dstcoord-grid","title":"class pybdy.tide.nemo_bdy_tide.Extract(setup, DstCoord, Grid)","text":"<p>Bases: <code>object</code></p>"},{"location":"pybdy.tide/#method-__init__setup-dstcoord-grid","title":"method __init__(setup, DstCoord, Grid)","text":""},{"location":"pybdy.tide/#method-extract_concon","title":"method extract_con(con)","text":""},{"location":"pybdy.tide/#pybdytidenemo_bdy_tide3-module","title":"pybdy.tide.nemo_bdy_tide3 module","text":"<p>Module to extract constituents for the input grid mapped onto output grid.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.tide/#pybdytidenemo_bdy_tide3constituents_indexconstituents-inputcons","title":"pybdy.tide.nemo_bdy_tide3.constituents_index(constituents, inputcons)","text":"<p>Convert the input contituents to index in the tidal constituents.</p>"},{"location":"pybdy.tide/#parameters","title":"Parameters","text":"<p>constituents: The list of constituents available from the source data :   e.g. TPXO: [\u2018m2\u2019, \u2018s2\u2019, \u2018n2\u2019, \u2018k2\u2019, \u2018k1\u2019, \u2018o1\u2019, \u2018p1\u2019, \u2018q1\u2019, \u2018mf\u2019, \u2018mm\u2019, \u2018m4\u2019, \u2018ms4\u2019, \u2018mn4\u2019]</p> <p>inputcons: The dictionary of constituents from the namelist with their numbers :   e.g. {\u20181\u2019: \u201c\u2018M2\u2019\u201d, \u20183\u2019: \u201c\u2018K2\u2019\u201d, \u20182\u2019: \u201c\u2018S2\u2019\u201d, \u20184\u2019: \u201c\u2018M4\u2019\u201d}</p>"},{"location":"pybdy.tide/#returns","title":"Returns","text":"<p>retindx: The indices (relative to the source data list) of the dictionary items from the namelist :   e.g. [ 0. 3. 1. 10.]</p>"},{"location":"pybdy.tide/#pybdytidenemo_bdy_tide3nemo_bdy_tide_rotsetup-dstcoord-grid_t-grid_u-grid_v-comp","title":"pybdy.tide.nemo_bdy_tide3.nemo_bdy_tide_rot(setup, DstCoord, Grid_T, Grid_U, Grid_V, comp)","text":"<p>Global Tidal model interpolation onto target grid, including grid rotation.</p>"},{"location":"pybdy.tide/#parameters_1","title":"Parameters","text":"<p>setup : settings DstCoord : destination coordinate object Grid_T : t grid bdy_i, grid_type, bdy_r Grid_U : u grid bdy_i, grid_type, bdy_r Grid_V : v grid bdy_i, grid_type, bdy_r comp : dictionary of harmonics read from namelist {\u20181\u2019:\u201dM2\u201d , \u20182\u2019:\u201d\u201d}</p>"},{"location":"pybdy.tide/#returns_1","title":"Returns","text":"<p>cosz, sinz, cosu, sinu, cosv, sinv: [of constituents, number of bdy points]</p>"},{"location":"pybdy.tide/#pybdytidenemo_bdy_tide_ncgen-module","title":"pybdy.tide.nemo_bdy_tide_ncgen module","text":"<p>Create a Tide netcdf file ready for population.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.tide/#pybdytidenemo_bdy_tide_ncgencreatebdytidenetcdffilefilename-xb_len-x_len-y_len-h-fv-grd","title":"pybdy.tide.nemo_bdy_tide_ncgen.CreateBDYTideNetcdfFile(filename, xb_len, x_len, y_len, h, fv, grd)","text":""},{"location":"pybdy.tide/#pybdytidetpxo_extract_hc-module","title":"pybdy.tide.tpxo_extract_HC module","text":"<p>Extract the tidal harmonic constants out of a tidal model for given locations.</p> <p>[amp,Gph] = tpxo_extract_HC(Model,lat,lon,type,Cid).</p> <p>original author: Mr. Srikanth Nagella</p> <p>TPXO data has a grid file and then data file for harmonic heights and harmonic currents In TPXO7.2 the resolution was sufficiently low that all the harmonics could be bundled together In TPXO9v5 the resolution increased such that separate files are issued for each constituent</p> <p>Files are processed in real and imaginary parts as they are easier to interpolate.</p>"},{"location":"pybdy.tide/#class-pybdytidetpxo_extract_hctpxoextractsettings-lat-lon-grid_type","title":"class pybdy.tide.tpxo_extract_HC.TpxoExtract(settings, lat, lon, grid_type)","text":"<p>Bases: <code>object</code></p> <p>TPXO model extract_hc.c implementation in python.</p>"},{"location":"pybdy.tide/#method-__init__settings-lat-lon-grid_type_1","title":"method __init__(settings, lat, lon, grid_type)","text":"<p>Initialise the Extract of tide information from the netcdf Tidal files.</p>"},{"location":"pybdy.tide/#method-generate_landmask_from_bathymetrybathy_name","title":"method generate_landmask_from_bathymetry(bathy_name)","text":"<p>Create a boolean mask xr.DataArray from bathymetry.</p> <p>TPXO7.2 carries a binary variable called mask and a bathymetry variable TPXO9v5 only carries the bathymetry variable</p> <p>return: mask dataarray.</p> <p>Useage: :   self.grid[mask_name] = generate_landmask(bathy_name)</p>"},{"location":"pybdy.tide/#method-interpolate_constituentsnc_dataset-real_var_name-img_var_name-lon_var_name-lat_var_name-lon-lat-height_datanone-masknamenone","title":"method interpolate_constituents(nc_dataset, real_var_name, img_var_name, lon_var_name, lat_var_name, lon, lat, height_data=None, maskname=None)","text":"<p>Interpolate the tidal constituents along the given lat lon coordinates.</p>"},{"location":"pybdy.tide/#pybdytidetpxo_extract_hcbilinear_interpolationlon-lat-data-lon_new-lat_new","title":"pybdy.tide.tpxo_extract_HC.bilinear_interpolation(lon, lat, data, lon_new, lat_new)","text":"<p>Do a bilinear interpolation of grid where the data values are NaN\u2019s.</p>"},{"location":"pybdy.tide/#pybdytidetpxo_extract_hcinterpolate_datalon-lat-data-mask-lonlat","title":"pybdy.tide.tpxo_extract_HC.interpolate_data(lon, lat, data, mask, lonlat)","text":"<p>Interpolate data data on regular grid for given lonlat coordinates.</p>"},{"location":"pybdy.tide/#module-contents","title":"Module contents","text":""},{"location":"pybdy.utils/","title":"pybdy.utils package","text":""},{"location":"pybdy.utils/#pybdyutils-package","title":"pybdy.utils package","text":""},{"location":"pybdy.utils/#submodules","title":"Submodules","text":""},{"location":"pybdy.utils/#pybdyutilsconstants-module","title":"pybdy.utils.Constants module","text":"<p>File with all the constants that will be used.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.utils/#pybdyutilse3_to_depth-module","title":"pybdy.utils.e3_to_depth module","text":"<p>Function e3_to_depth.</p> <p>Purpose : compute t- &amp; w-depths of model levels from e3t &amp; e3w scale factors Method : The t- &amp; w-depth are given by the summation of e3w &amp; e3t, resp. Action : pe3t, pe3w : scale factor of t- and w-point (m) Useage: [gdept, gdepw] = e3_to_depth(e3t, e3w, nz).</p>"},{"location":"pybdy.utils/#pybdyutilse3_to_depthe3_to_depthpe3t-pe3w-jpk","title":"pybdy.utils.e3_to_depth.e3_to_depth(pe3t, pe3w, jpk)","text":""},{"location":"pybdy.utils/#pybdyutilsgcoms_break_depth-module","title":"pybdy.utils.gcoms_break_depth module","text":"<p>Rewritting the break depth implementation from matlab version.</p> <p>@author: Mr. Srikanth Nagella</p>"},{"location":"pybdy.utils/#pybdyutilsgcoms_break_depthgcoms_boundary_masksbathy-ov-lv","title":"pybdy.utils.gcoms_break_depth.gcoms_boundary_masks(bathy, ov, lv)","text":"<p>_Summary.</p>"},{"location":"pybdy.utils/#parameters","title":"Parameters","text":"<ul> <li>type bathy:</li> <li>param bathy:     This is the input bathymetry data</li> <li>type ov:</li> <li>param ov:     Latittude array</li> <li>type lv:</li> <li>param lv:     Longitude array</li> <li>type bathy:     numpy array</li> <li>type ov:     numpy array</li> <li>type lv:     numpy array</li> <li>return:     returns the ob, lb</li> <li>rtype:     numpy arrays</li> <li>Example:</li> </ul>"},{"location":"pybdy.utils/#pybdyutilsgcoms_break_depthgcoms_break_depthbathy","title":"pybdy.utils.gcoms_break_depth.gcoms_break_depth(bathy)","text":"<p>Create a mask for the break depth using histograms.</p>"},{"location":"pybdy.utils/#pybdyutilsgcoms_break_depthpolcoms_select_domainbathy-lat-lon-roi-dr","title":"pybdy.utils.gcoms_break_depth.polcoms_select_domain(bathy, lat, lon, roi, dr)","text":"<p>Calculate the shelf break.</p> <ul> <li>Parameters</li> </ul> <ul> <li>bathy (numpy array) \u2013 This is the input bathymetry data</li> <li>lat (numpy array) \u2013 Latittude array</li> <li>lon (numpy array) \u2013 Longitude array</li> <li>roi (python array) \u2013 region of interest array [4]</li> <li>dr (float) \u2013 shelf break distance</li> </ul> <ul> <li>Returns     returns the depth_shelf, h_max</li> <li>Return type:     numpy arrays.</li> <li>Example:</li> </ul>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_lib-module","title":"pybdy.utils.nemo_bdy_lib module","text":"<p>Library of some functions used by multiple classes.</p> <p>Written by John Kazimierz Farey, Sep 2012.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libbdy_sectionsnbidta-nbjdta-nbrdta-rw","title":"pybdy.utils.nemo_bdy_lib.bdy_sections(nbidta, nbjdta, nbrdta, rw)","text":"<p>Extract individual byd sections.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libbdy_transport","title":"pybdy.utils.nemo_bdy_lib.bdy_transport()","text":"<p>Calculate transport across individual bdy sections.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libdistself-x-y","title":"pybdy.utils.nemo_bdy_lib.dist(self, x, y)","text":"<p>Return the distance between two points.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libdist_point_to_segmentp-s0-s1","title":"pybdy.utils.nemo_bdy_lib.dist_point_to_segment(p, s0, s1)","text":"<p>Get the distance of a point to a segment.</p> <p>p, s0, s1 are xy sequences This algorithm from</p> <p>http://geomalgorithms.com/a02-_lines.html.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libget_output_filenamesetup_var-year-month-var_type","title":"pybdy.utils.nemo_bdy_lib.get_output_filename(setup_var, year, month, var_type)","text":"<p>Return a output filename constructed for a given var_type, year and month.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libget_output_tidal_filenamesetup_var-const_name-grid_type","title":"pybdy.utils.nemo_bdy_lib.get_output_tidal_filename(setup_var, const_name, grid_type)","text":"<p>Return a output filename constructed for a given tidal constituent and grid type.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libpsi_fieldu-v","title":"pybdy.utils.nemo_bdy_lib.psi_field(U, V)","text":""},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_librot_reppxin-pyin-dummy-cd_todo-gcos-gsin","title":"pybdy.utils.nemo_bdy_lib.rot_rep(pxin, pyin, dummy, cd_todo, gcos, gsin)","text":"<p>Rotate function.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libsub2indshap-subx-suby","title":"pybdy.utils.nemo_bdy_lib.sub2ind(shap, subx, suby)","text":"<p>Subscript to index of a 1d array.</p>"},{"location":"pybdy.utils/#pybdyutilsnemo_bdy_libvelocity_fieldpsi","title":"pybdy.utils.nemo_bdy_lib.velocity_field(psi)","text":""},{"location":"pybdy.utils/#module-contents","title":"Module contents","text":""}]}