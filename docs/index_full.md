# pyBDY Documentation

**Welcome to the documentation for pyBDY (NEMO lateral boundary conditions)**

## Introduction

pyBDY is a python package to generate lateral boundary conditions for regional NEMO model configurations.
It has been developed to uses geographical and depth information from an a source data (e.g. a global ocean
simulation) and translate them to a destination NEMO region simulation. It makes use of a kdtree approximate
nearest neighbour algorithm in order to provide a generic method of weighted average interpolation for any
flavour of ocean model. The available options are accessed either through a NEMO style namelist.

---

## Contents

- [How to cite :bookmark:](#how-to-cite-bookmark)
- [Change Log :twisted_rightwards_arrows:](#change-log-twisted_rightwards_arrows)
- [Dependencies :globe_with_meridians:](#dependencies-globe_with_meridians)
- [Quick Start Installation :rocket:](#quick-start-installation-rocket)
- [How to use pyBDY :mechanical_arm:](#how-to-use-pybdy-mechanical_arm)
- [Tidal Boundary Conditions Generation :sailboat:](#tidal-boundary-conditions-generation-sailboat)
- [CMEMS Downloader :inbox_tray:](#cmems-downloader-inbox_tray)
- [Troubleshooting :safety_vest:](#troubleshooting-safety_vest)
- [pyBDY Module Structure :scroll:](#pybdy-module-structure-scroll)

## How to cite :bookmark:

[Back to top](#pybdy-documentation)

Please cite pyBDY version 0.4.0 in your work using:

Harle, J., Barton, B.I., Nagella, S., Crompton, S., Polton J., Patmore, R., Morado, J., Thopri, Wise, A., De Dominicis, M., Blaker, A. Farey, J.K., (2025). pyBDY - NEMO lateral boundary conditions v0.4.0 [Software]. [https://doi.org](<>)

## Change Log :twisted_rightwards_arrows:

[Back to top](#pybdy-documentation)

The lastes version of pyBDY is version 0.4.0.
The changes relative to the previous version (0.3.0) are:

- Sigma to sigma vertical layer interpolation is now possible.
- Vertical interpolation in pyBDY can now be turned off for zco vertical coodinate data.
- Time input in the namelist has changed to offer more granularity.
- Grid variables names are now specified using a .json file instead of .ncml. Source data is still specified with .nmcl.
- The boundary is split into chunks to allow for processing smaller sections of data.
- Boundaries that cross an east - west wrap in source data can be processed.
- The 1-2-1 horizontal filter has been turned off.
- The *seawater* dependancy updated to *gsw*.
- A plotting masking bug has been fixed.
- Bug fix for 90 boundaries that meet diagonally to produce a 90 degree corner.
- Some unit tests have been added and full integration tests.
- Documentation has been updated and restructured.

**There is a new library for generating NEMO initial conditions called pyIC.**
pyIC can be found at: [https://github.com/NOC-MSM/pyIC](https://github.com/NOC-MSM/pyIC)

## Dependencies :globe_with_meridians:

[Back to top](#pybdy-documentation)

pyBDY is installed under a conda/mamba environment to aid wider distribution and to facilitate development.
The key dependecies are listed below:

- python=3.9
- netCDF4
- scipy
- numpy
- xarray
- matplotlib
- cartopy
- thredds_crawler
- seawater
- pyqt5
- pyjnius
- cftime
- gsw

A recent JAVA installation is also required.

---

## Quick Start Installation :rocket:

[Back to top](#pybdy-documentation)

To get started, check out and set up an instance of the pyBDY GitHub [repository](https://github.com/NOC-MSM/pyBDY):

```sh
export PYBDY_DIR=$PWD/pyBDY
git clone git@github.com:NOC-MSM/pyBDY.git
```

\*\*Helpful Tip...

```
- **It is not advised to checkout the respository in your home directory.**
```

Creating a specific conda virtual environment is highly recommended ([click here for more about virtual
enviroments](https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html)).
Load conda (e.g. through anaconda/miniforge) and create the environment through the provided `environment.yml` file.

```sh
cd $PYBDY_DIR
conda env create -n pybdy -f environment.yml
```

Activate the new environment

```sh
conda activate pybdy
```

Install pyBDY

```sh
pip install -e .
```

Make sure the Java Runtime Environment is set:

```sh
export JAVA_HOME=path_to_jre
```

Generalised methods for defining paths are as follows:

```
export JAVA_HOME=$(readlink -f $(which java)) # UNIX
export JAVA_HOME=$(/usr/libexec/java_home)    # Mac
```

To check that pyBDY have been correctly installed in the virtual environment,
enter the following command:

```
pybdy -v
```

If it has you should see the help usage prompt:

```
usage: pybdy -g -s <namelist.bdy>
```

If not please see the troubleshooting pages for common causes as
to why the installation may fail.

To deactivate the conda environment:

```
conda deactivate
```

## How to use pyBDY :mechanical_arm:

[Back to top](#pybdy-documentation)

In this documentation "bdy points" refer to the output boundary points generated by pyBDY.
First follow the installation instructions [Quick Start Installation](#quick-start-installation-rocket).

### Step 1: File Preparation

Copy and paste the following files into your working directory:

- `inputs/namelist_local.bdy`

- `inputs/grid_name_map.json`

- `inputs/src_data_local.ncml`

- `namelist.bdy`: Specifies file paths and configuration options.

- `grid_name_map.json`: Defines variable names in horizontal and vertical grid files.

- `src_data.ncml`: Aggregates and remaps source data variables for PyBDY.

### Step 2: Edit the Namelist `namelist_local.bdy`

Descriptions of all required variables are in
[`src/pybdy/variable.info`](https://github.com/NOC-MSM/pyBDY/blob/master/src/pybdy/variable.info).
Here we will summarise the main variables that will need changing to get started.

#### Key Namelist Parameters

- `sn_src_hgr`
- `sn_src_zgr`
- `sn_dst_hgr`
- `sn_dst_zgr`
- `sn_src_msk`
- `sn_bathy`
- `sn_nme_map`
- `sn_src_dir`
- `sn_dst_dir`
- `cn_mask_file`
- `ln_zinterp`
- `nn_rimwidth`

##### File Paths

Directory paths in bdy file can be relative or absolute.
The application picks the relative path from the current working directory.

- **`sn_src_hgr`**: Source horizontal grid file. Should include:

    - Ideal: `glamt`, `gphit`, `glamu`, `e1t`, `e2t`, `e1u`, etc.
    - Minimum: `nav_lat`, `nav_lon` on a 2D grid.
    - Use `ncdump -h` or `ncview` to inspect variables.
    - Map extra variable names in `grid_name_map.json` to avoid recalculation.

- **`sn_src_zgr`**: Source vertical grid file. May be the same as `sn_src_hgr`.

    - Ideal: `gdept`, `e3t`, `mbathy` (aka `bottom_level`)
    - If `mbathy` is missing:
        - Use `gdept_0` (1D depth)
        - Use any 2D field (e.g., `nav_lon`) for `mbathy`
        - **Not recommended for destination**
    - Map variables like `gdepw`, `gdepu`, `e3w` in `grid_name_map.json`
    - **Note**: Time-varying depths are not used in PyBDY.

- **`sn_dst_hgr`, `sn_dst_zgr`**: Destination equivalents of the above.

- **`sn_src_msk`**: Source mask file with variables:

    - `tmask`, `umask`, `vmask`, `fmask`

- **`sn_bathy`**: Destination bathymetry file with variable:

    - `Bathymetry`

    - Used to calculate boundary mask if `ln_mask_file` is unset.

    - Can be computed from `e3w` and `bottom_level`:

        ```python
        gdepw = np.cumsum(e3w, axis=1)
        grid = np.indices(bottom_level.shape)
        bathy = gdepw[bottom_level, grid[0], grid[1]]
        ```

- **`sn_nme_map`**: Path to `grid_name_map.json`

    - **Note**: `ncml` is no longer used for grid input. Use `grid_name_map.json` instead. See [`inputs/grid_name_map_readme.txt`](https://github.com/NOC-MSM/pyBDY/blob/master/inputs/grid_name_map_readme.txt) for variable descriptions.

- **`sn_src_dir`**: Path to `src_data.ncml`

    - This is an xml file that points to source data (not grid) paths. It can also include THREDDS URLs (see `inputs/namelist_remote.bdy` for example).
    - See `inputs` folder for more examples.

    Example structure:

    ```xml
    <ns0:netcdf xmlns:ns0="http://www.unidata.ucar.edu/namespaces/netcdf/ncml-2.2" title="aggregation example">
      <ns0:aggregation type="union">
        <ns0:netcdf>
          <ns0:aggregation type="joinExisting" dimName="time_counter">
            <ns0:scan location="/path_to_src_data/Data/" regExp=".*grid_T.*" />
          </ns0:aggregation>
        </ns0:netcdf>
        <ns0:netcdf>
          <ns0:aggregation type="joinExisting" dimName="time_counter">
            <ns0:scan location="/path_to_src_data/Data/" regExp=".*grid_U.*" />
          </ns0:aggregation>
        </ns0:netcdf>
        <ns0:netcdf>
          <ns0:aggregation type="joinExisting" dimName="time_counter">
            <ns0:scan location="/path_to_src_data/Data/" regExp=".*grid_V.*" />
          </ns0:aggregation>
        </ns0:netcdf>
      </ns0:aggregation>
    </ns0:netcdf>
    ```

    - Regular expression (Regex) is a special text string that can be used in the xml file for describing a search pattern to match against some text. You may compare using regex to filter what files to include in your datasets against using wildcard (\*) to specify a file search pattern in your computer. More information on Regex patterns can be found here [Regex](https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference).

- **`sn_dst_dir`**: Output directory for PyBDY data

##### Other Settings

- **`cn_mask_file`** *(optional)*: Used to define open boundaries.

    - Values: `-1` (out-of-domain), `0` (land), `1` (water)
    - If not provided, PyBDY uses bathymetry to infer boundaries

- **`ln_zinterp`**: Disables vertical interpolation if `false` and source uses zco levels.

    - Output will match source vertical levels
    - If source uses zps or sco, this will be set to `true` automatically

- **`nn_rimwidth`**: Number of interior boundary points to generate

    - Typical value: `9`
    - For tidal boundaries: `1`

#### Time Settings

- Ensure `time_counter` exists in source files
- Files must be time-ascending
- NetCDF time metadata must include:
    - `calendar`: `"gregorian"`, `"noleap"`, or `"360_day"`
    - `units`: `"seconds since YYYY-MM-DD hh:mm:ss"`

##### Required Namelist Time Parameters

- **`sn_date_start`**: Start date for output (format: `YYYY-MM-DD`)
- **`sn_date_end`**: End date for output (format: `YYYY-MM-DD`)
    - The start date and end date of output must fall within the source data time range.
- **`sn_dst_calendar`**: Output calendar format
- **`sn_date_origin`**: Time counter reference date for output (format: `YYYY-MM-DD`)
- **`ln_time_interpolation`**: If `true`, interpolate to daily steps.
    - If `false`, output uses source data calendar (monthly steps only)

### Step 3: Running pyBDY

To use pyBDY, the following command is entered: (the example will run a benchmarking test):

```
pybdy -s /path/to/namelist/file (e.g. ./inputs/namelist_remote.bdy)
```

This command line tool reads a BDY file, extracts boundary data and prepares the data for a NEMO simulation.

## Tidal Boundary Conditions Generation :sailboat:

[Back to top](#pybdy-documentation)

By providing a global tidal model dataset (TPXO and FES are currently supported) pyBDY can generate boundary conditions for the NEMO configuration supplied using the namelist file.

### Namelist options

To use the namelist needs to be configured with the required options. These are listed below:

```
ln_tide        = .true.              !  =T : produce bdy tidal conditions
sn_tide_model  = 'FES2014'           !  Name of tidal model. Accepts FES2014, TPXO7p2, or TPXO9v5
clname(1)      = 'M2'                !  constituent name
clname(2)      = 'S2'
clname(3)      = 'K2'
clname(4)      = 'O1'
clname(5)      = 'P1'
clname(6)      = 'Q1'
clname(7)      = 'M4'
ln_trans       = .true.              !  interpolate transport rather than velocities
! location of TPXO7.2 data
sn_tide_grid_7p2   = './inputs/tpxo7.2/grid_tpxo7.2.nc'
sn_tide_h          = './inputs/tpxo7.2/h_tpxo7.2.nc'
sn_tide_u          = './inputs/tpxo7.2/u_tpxo7.2.nc'
! location of TPXO9v5 data: single constituents per file
sn_tide_grid_9p5   = './inputs/TPXO9_atlas_v5_nc/grid_tpxo9_atlas_30_v5.nc'
sn_tide_dir        = './inputs/TPXO9_atlas_v5_nc/'
! location of FES2014 data
sn_tide_fes        = './inputs/FES2014/'
```

These options define the location of the tidal model datasets, note this differs depending on model as TPXO has all harmonic constants in one netcdf file whereas FES has three separate netcdf files (one for amplitude two for currents) for each constant. Extra harmonics can be appended to the clname(n) list. FES supports 34 constants and TPXO7.2 has 13 to choose from. Other versions of TPXO should work with pyBDY but have not been yet been tested. NOTE FES dataset filenames must have be in the format of constituent then type. e.g.:

```
M2_Z.nc (for amplitude)
M2_U.nc (for U component of velocity)
M2_V.nc (for V component of velocity)
```

If this is not undertaken the pyBDY will not recognise the files. TPXO data files are specified directly so these can be anyname although it is best to stick with the default names as shown above. So far the tidal model datasets have been downloaded and used locally but could also be stored on a THREDDS server although this has not been tested with the global tide models.

Other options include “ln_tide” a boolean that when set to true will generate tidal boundaries. “sn_tide_model” is a string that defines the model to use, currently only “fes” or “tpxo” are supported. “ln_trans” is a boolean that when set to true will interpolate transport rather than velocities.

### Harmonic Output Checker

There is an harmonic output checker that can be utilised to check the output of pyBDY with a reference tide model. So far the only supported reference model is FES but TPXO will be added in the future. Any tidal output from pyBDY can be checked (e.g. FES and TPXO). While using the same model used as input to check output doesn’t improve accuracy, it does confirm that the output is within acceptable/expected limits of the nearest model reference point.

There are differences as pyBDY interpolates the harmonics and the tidal checker does not, so there can be some difference in the values particularly close to coastlines.

The checker can be enabled by editing the following in the relevent bdy file:

```
ln_tide_checker = .true.                ! run tide checker on pyBDY tide output
sn_ref_model    = 'fes'                 ! which model to check output against (FES only)
```

The boolean determines if to run the checker or not, this takes place after creating the interpolated harmonics and writing them to disk. The string denotes which tide model to use as reference, so far only FES is supported. The string denoting model is not strictly needed, by default fes is used.

The checker will output information regarding the checking to the NRCT log, and also write an spreadsheet to the output folder containing any exceedance values, the closest reference model value and their locations. Amplitude and phase are checked independently, so both have latitude and longitude associated with them. It is also useful to know the amplitude of a exceeded phase to see how much impact it will have so this is also written to the spreadsheet. An example output is shown below, as can be seen the majority of the amplitudes, both the two amplitudes exceedances and the ones associated with the phase exceedances are low (~0.01), so can most likely be ignored. There a few phase exceedances that have higher amplitudes (~0.2) which would potentially require further investigation. A common reason for such an exceedance is due to coastlines and the relevant point being further away from an FES data point.

The actual thresholds for both amplitude and phase are based on the amplitude of the output or reference, this is due to different tolerances based on the amplitude. e.g. high amplitudes should have lower percentage differences to the FES reference, than lower ones simply due to the absolute amount of the ampltiude itself, e.g. a 0.1 m difference for a 1.0 m amplitude is acceptable but not for a 0.01 m amplitude. The smaller amplitudes contribute less to the overall tide height so larger percentage differences are acceptable. The same also applies to phases, where large amplitude phases have little room for differences but at lower amplitudes this is less critical so a higher threshold is tolerated.

The following power functions are used to determine what threshold to apply based on the reference model amplitude.

#### Amplitude Threshold

```
Percentage Exceedance = 26.933 * Reference Amplitude ^ -0.396’
```

#### Phases Threshold

```
Phase Exceedance = 5.052 * pyBDY Amplitude ^ -0.60
```

## CMEMS Downloader :inbox_tray:

[Back to top](#pybdy-documentation)

IMPORTANT The CMEMS downloader has not been tested recently (May 2025).
IMPORTANT The CMEMS downloader has only been tested with the GLOBAL_ANALYSIS_FORECAST_PHY_001_024 model and specifcally the hourly SSH and U V product. This also has temperature stored within it, but not salinity. Other models and products should work but are currently likely to need some changes to the code to cope with different variable names within the data. This will be fixed in a later release of pyBDY that is able to handle different variable and tracer names.

pyBDY has a CMEMS downloading function incorporated within it, this will download a section of the CMEMS global model (more models to be added) ‘GLOBAL_ANALYSIS_FORECAST_PHY_001_024-TDS’ for the defined time period in the namelist file

To use the downloading function, the following command is used:

```
$ pynemo -d namelist.bdy
```

Where the -d flag tells pyBDY to use the CMEMS downloader and download data as specified in the namelist file. The log file that pyBDY produces provides a log of what the downloader does. The CMEMS MOTU system is prone to disconnects and failure so there is download retry and error handling built in. Most of the options required should not need editing and are there for future use in case URL’s and filenames on CMEMS change.

The options that can be configured are described in further detail below:

```
!------------------------------------------------------------------------------
!  I/O
!------------------------------------------------------------------------------
   sn_src_dir = '/Users/thopri/Projects/pyBDY/inputs/CMEMS.ncml' ! src_files/'
   sn_dst_dir = '/Users/thopri/Projects/pyBDY/outputs'

   sn_fn      = 'NNA_R12'             ! prefix for output files
   nn_fv      = -1e20                 !  set fill value for output files
   nn_src_time_adj = 0                ! src time adjustment
   sn_dst_metainfo = 'CMEMS example'

!------------------------------------------------------------------------------
!  CMEMS Data Source Configuration
!------------------------------------------------------------------------------
   ln_use_cmems             = .true.
   ln_download_cmems        = .true.
   sn_cmems_dir             = '/Users/thopri/Projects/pyBDY/inputs/' ! where to download CMEMS input files (static and variable)
   ln_download_static       = .true.
   ln_subset_static         = .true.
   nn_num_retry             = 4 ! how many times to retry CMEMS download after non critical errors?
!------------------------------------------------------------------------------
!  CMEMS MOTU Configuration (for Boundary Data)
!------------------------------------------------------------------------------
   sn_motu_server           = 'http://nrt.cmems-du.eu/motu-web/Motu'
   sn_cmems_config_template = '/Users/thopri/Projects/pyBDY/pynemo/config/motu_config_template.ini'
   sn_cmems_config          = '/Users/thopri/Projects/pyBDY/pynemo/config/motu_config.ini'
   sn_cmems_model           = 'GLOBAL_ANALYSIS_FORECAST_PHY_001_024-TDS'
   sn_cmems_product         = 'global-analysis-forecast-phy-001-024'
   sn_dl_prefix             = 'subset'
!------------------------------------------------------------------------------
!  CMEMS FTP Configuration (for Static Files)
!------------------------------------------------------------------------------
    sn_ftp_server            = 'nrt.cmems-du.eu'
    sn_static_dir            = '/Core/GLOBAL_ANALYSIS_FORECAST_PHY_001_024/global-analysis-forecast-phy-001-024-statics'
    sn_static_filenames      = 'GLO-MFC_001_024_coordinates.nc GLO-MFC_001_024_mask_bathy.nc GLO-MFC_001_024_mdt.nc'
    sn_cdo_loc               = '/opt/local/bin/cdo' ! location of cdo executable can be found by running "where cdo"
!------------------------------------------------------------------------------
!  CMEMS Extent Configuration
!------------------------------------------------------------------------------
    nn_latitude_min          = 40
    nn_latitude_max          = 66
    nn_longitude_min         = -22
    nn_longitude_max         = 16
    nn_depth_min             = 0.493
    nn_depth_max             = 5727.918000000001
```

Some of the options define the behaviour of the downloader, others define locations to save files and others detail models and grid files to download. Finally the spatial extent to download is also required.

#### I/O and NCML file

The location of the NCML file is listed a string defining the source directory or “sn_src_dir”. The output folder is also defined here as “sn_dst_dir”, NOTE if this directory does not exist it will need to be created and permissoned correctly for pyBDY to run properly. The NCML file details the input files to agregate and what the variable names are. Variable names are in [https://resources.marine.copernicus.eu/?option=com_csw&task=results](https://resources.marine.copernicus.eu/?option=com_csw&task=results) For more information please read the ncml part.

NOTE A NCML file must be used and it also must use a regular expression. The CMEMS downloader uses this regular expression to determine what grid a given variable is part of e.g. temperature and salinity on the T grid. The example CMEMS.ncml file includes: an implementation of how to define temperature, SSH and U and V components of ocean currents.

Firstly, the string “sn_fn” defines the prefix for the output files. The number “nn_fv” defines the fill value, and the number “nn_src_time_adj” defines the source time adjustment. The rest of the boxes are CMEMS specific.

#### Data Source Configuration

The first section defines the CMESM data source configuration. The boolean “ln_use_cmems” when set to true will use the CMEMS downloader function to download the requested data, this is defined in the ncml file which can be generated using the NCML generator. Among other things this file defines what data variables to download. This term also changes the variable names to CMEMS specific ones e.g. thetao for temperature and so for salinity. This is in contrast to the NEMO specific ones such as Votemper and Vosaline. When set to false no download occurs and variable names are kept to NEMO specific.

#### MOTU Configuration

In the next section when set to true “ln_download_cmems” will download the boundary tracer data, e.g. time series of temperature and saliniy. When set to false pyBDY will skip this download. The string “sn_cmems_dir” defines where to save these downloaded files. pyBDY requires grid data, this isn’t possible to download using the same method as the tracer data which uses the MOTU python client. To get the grid data, an ftp request is made to download the global grids which are then subset to the relevent size. The booleans “ln_downlad_static” and “ln_subset_static” determine this behavior. Finally there is an int named “nn_num_retry” this defines the number of times to retry downloading the CMEMS data. The data connections are prone to failure so if a non critical error occurs the function will automatically try to redownload. This int defines how many times it will try to do this. Typically this static data and subsetting are only required once so these can be set to true for first download and then set to false when more time series data is required.

As mentioned previously, the time series boundary data is downloaded using MOTU, this is an efficent and robust web server that handles, extracts and transforms oceanographic data. By populating a configuration file, this can be sent to the MOTU server which will return the requested data in the requested format. The section CMEMS MOTU configuration sets this up. Most of these options should not need changing. The location of the MOTU server for CMEMS is defined here, and the location of the config template file and also the location of the config file to submit. The only options that should require changing are the model, product and prefix options. These define which CMEMS model and product to download and the prefix is a user defined string to prefix the downloads. A catalogue of the CMEMS model and products can be found at https://resources.marine.copernicus.eu/?option=com_csw&task=results Currently pyBDY has only been tested using the physical global forecast model although the downloader should be able to download other models and products, it has not been tested and their are known issues with other products that restrict seamless download. e.g. the NorthWest Atlantic model is not currently compatible due to differences in how the model variables are stored.

#### FTP Configuration for Static and Grid files

The next section CMEMS FTP configuration, defines which FTP server, remote directory and files to download. This should require modification unless CMEMS changes the file structure or names. Note it is important that the filenames are separated by a space as this is what pyBDY is expecting. Finally the location of CDO executable which should be installed to enable subsetting to occur. This can be found by running:

```
$ where cdo
```

#### Extent configuration

Finally the last box, this is where the extent to download is configured, it is up to the user to decide but it is suggested this is at least 1 degree wider than the destination or child configuration. The depth range to request is also defined here. This information can be extracted from the CMEMS catalogue. Once set for a given configuration this will not need to be edited.

## Troubleshooting :safety_vest:

[Back to top](#pybdy-documentation)

Always check the pyBDY log file. This is usually saved in the working directory of pyBDY as nrct.log. It gives helpful information which may help to diagnose issues. E.g. ValueErrors that are result of a THREDDS server being down and unable to provide data files.

If you get the error message "Destination touches source i-edge but source is not cylindrical" or you get the error message "Destination touches source j-edge but North Fold is not implemented". There is a plot you can uncomment in pybdy.nemo_bdy_chunk.chunk_bdy() that will show you where pyBDY is attempting to place bdy points.

- For "Destination touches source i-edge but source is not cylindrical", you may have an open boundary in your mask or bathymetry file that is not inside the domain of the source data. If this is the case you need to edit your mask to be land (i.e. zeros) to block the incorrect open boundary.
- For "Destination touches source j-edge but North Fold is not implemented", your domain probably touches the Arctic North Fold and pyBDY is trying to put an open boundary there. If this is the case you need to edit your mask to be land (i.e. zeros) to block the incorrect open boundary along the north edge of the domain. Do not attept to have a regional model with a boundary crossing the North Fold, this has not be implemented yet.

If you have time interpolation problems read the section [Time Settings](#time-settings).

## pyBDY Module Structure :scroll:

[Back to top](#pybdy-documentation)

Here is a list of all the classes, methods and functions in pyBDY.

- [grid package](grid.md)
    - [Submodules](grid.md#submodules)
    - [grid.hgr module](grid.md#module-grid.hgr)
        - [`H_Grid`](grid.md#grid.hgr.H_Grid)
            - [`H_Grid.__init__()`](grid.md#grid.hgr.H_Grid.__init__)
            - [`H_Grid.find_hgrid_type()`](grid.md#grid.hgr.H_Grid.find_hgrid_type)
            - [`H_Grid.get_vars()`](grid.md#grid.hgr.H_Grid.get_vars)
        - [`calc_e1_e2()`](grid.md#grid.hgr.calc_e1_e2)
        - [`calc_grid_from_t()`](grid.md#grid.hgr.calc_grid_from_t)
        - [`fill_hgrid_vars()`](grid.md#grid.hgr.fill_hgrid_vars)
    - [grid.zgr module](grid.md#module-grid.zgr)
        - [`Z_Grid`](grid.md#grid.zgr.Z_Grid)
            - [`Z_Grid.__init__()`](grid.md#grid.zgr.Z_Grid.__init__)
            - [`Z_Grid.find_zgrid_type()`](grid.md#grid.zgr.Z_Grid.find_zgrid_type)
            - [`Z_Grid.get_vars()`](grid.md#grid.zgr.Z_Grid.get_vars)
        - [`calc_gdepw()`](grid.md#grid.zgr.calc_gdepw)
        - [`fill_zgrid_vars()`](grid.md#grid.zgr.fill_zgrid_vars)
        - [`horiz_interp_e3_old()`](grid.md#grid.zgr.horiz_interp_e3_old)
        - [`horiz_interp_lev()`](grid.md#grid.zgr.horiz_interp_lev)
        - [`vert_calc_e3()`](grid.md#grid.zgr.vert_calc_e3)
    - [Module contents](grid.md#module-grid)
- [pybdy package](pybdy.md)
    - [Subpackages](pybdy.md#subpackages)
        - [pybdy.gui package](pybdy.gui.md)
            - [Submodules](pybdy.gui.md#submodules)
            - [pybdy.gui.mynormalize module](pybdy.gui.md#module-pybdy.gui.mynormalize)
            - [pybdy.gui.nemo_bdy_input_window module](pybdy.gui.md#module-pybdy.gui.nemo_bdy_input_window)
            - [pybdy.gui.nemo_bdy_mask module](pybdy.gui.md#module-pybdy.gui.nemo_bdy_mask)
            - [pybdy.gui.nemo_bdy_mask_gui module](pybdy.gui.md#module-pybdy.gui.nemo_bdy_mask_gui)
            - [pybdy.gui.nemo_bdy_namelist_edit module](pybdy.gui.md#module-pybdy.gui.nemo_bdy_namelist_edit)
            - [pybdy.gui.nemo_ncml_generator module](pybdy.gui.md#module-pybdy.gui.nemo_ncml_generator)
            - [pybdy.gui.nemo_ncml_tab_widget module](pybdy.gui.md#module-pybdy.gui.nemo_ncml_tab_widget)
            - [pybdy.gui.selection_editor module](pybdy.gui.md#module-pybdy.gui.selection_editor)
            - [Module contents](pybdy.gui.md#module-pybdy.gui)
        - [pybdy.reader package](pybdy.reader.md)
            - [Submodules](pybdy.reader.md#submodules)
            - [pybdy.reader.directory module](pybdy.reader.md#module-pybdy.reader.directory)
            - [pybdy.reader.factory module](pybdy.reader.md#module-pybdy.reader.factory)
            - [pybdy.reader.ncml module](pybdy.reader.md#module-pybdy.reader.ncml)
            - [Module contents](pybdy.reader.md#module-pybdy.reader)
        - [pybdy.tide package](pybdy.tide.md)
            - [Submodules](pybdy.tide.md#submodules)
            - [pybdy.tide.fes2014_extract_HC module](pybdy.tide.md#module-pybdy.tide.fes2014_extract_HC)
            - [pybdy.tide.nemo_bdy_tide module](pybdy.tide.md#module-pybdy.tide.nemo_bdy_tide)
            - [pybdy.tide.nemo_bdy_tide3 module](pybdy.tide.md#module-pybdy.tide.nemo_bdy_tide3)
            - [pybdy.tide.nemo_bdy_tide_ncgen module](pybdy.tide.md#module-pybdy.tide.nemo_bdy_tide_ncgen)
            - [pybdy.tide.tpxo_extract_HC module](pybdy.tide.md#module-pybdy.tide.tpxo_extract_HC)
            - [Module contents](pybdy.tide.md#module-pybdy.tide)
        - [pybdy.utils package](pybdy.utils.md)
            - [Submodules](pybdy.utils.md#submodules)
            - [pybdy.utils.Constants module](pybdy.utils.md#module-pybdy.utils.Constants)
            - [pybdy.utils.e3_to_depth module](pybdy.utils.md#module-pybdy.utils.e3_to_depth)
            - [pybdy.utils.gcoms_break_depth module](pybdy.utils.md#module-pybdy.utils.gcoms_break_depth)
            - [pybdy.utils.nemo_bdy_lib module](pybdy.utils.md#module-pybdy.utils.nemo_bdy_lib)
            - [Module contents](pybdy.utils.md#module-pybdy.utils)
    - [Submodules](pybdy.md#submodules)
    - [pybdy.nemo_bdy_chunk module](pybdy.md#module-pybdy.nemo_bdy_chunk)
        - [`chunk_bdy()`](pybdy.md#pybdy.nemo_bdy_chunk.chunk_bdy)
        - [`chunk_corner()`](pybdy.md#pybdy.nemo_bdy_chunk.chunk_corner)
        - [`chunk_land()`](pybdy.md#pybdy.nemo_bdy_chunk.chunk_land)
        - [`chunk_large()`](pybdy.md#pybdy.nemo_bdy_chunk.chunk_large)
    - [pybdy.nemo_bdy_dst_coord module](pybdy.md#module-pybdy.nemo_bdy_dst_coord)
        - [`DstCoord`](pybdy.md#pybdy.nemo_bdy_dst_coord.DstCoord)
    - [pybdy.nemo_bdy_extr_assist module](pybdy.md#module-pybdy.nemo_bdy_extr_assist)
        - [`check_wrap()`](pybdy.md#pybdy.nemo_bdy_extr_assist.check_wrap)
        - [`distance_weights()`](pybdy.md#pybdy.nemo_bdy_extr_assist.distance_weights)
        - [`get_ind()`](pybdy.md#pybdy.nemo_bdy_extr_assist.get_ind)
        - [`get_vertical_weights()`](pybdy.md#pybdy.nemo_bdy_extr_assist.get_vertical_weights)
        - [`get_vertical_weights_zco()`](pybdy.md#pybdy.nemo_bdy_extr_assist.get_vertical_weights_zco)
        - [`interp_horizontal()`](pybdy.md#pybdy.nemo_bdy_extr_assist.interp_horizontal)
        - [`interp_vertical()`](pybdy.md#pybdy.nemo_bdy_extr_assist.interp_vertical)
        - [`valid_index()`](pybdy.md#pybdy.nemo_bdy_extr_assist.valid_index)
    - [pybdy.nemo_bdy_extr_tm3 module](pybdy.md#module-pybdy.nemo_bdy_extr_tm3)
        - [`Extract`](pybdy.md#pybdy.nemo_bdy_extr_tm3.Extract)
            - [`Extract.__init__()`](pybdy.md#pybdy.nemo_bdy_extr_tm3.Extract.__init__)
            - [`Extract.cal_trans()`](pybdy.md#pybdy.nemo_bdy_extr_tm3.Extract.cal_trans)
            - [`Extract.extract_month()`](pybdy.md#pybdy.nemo_bdy_extr_tm3.Extract.extract_month)
            - [`Extract.time_delta()`](pybdy.md#pybdy.nemo_bdy_extr_tm3.Extract.time_delta)
            - [`Extract.time_interp()`](pybdy.md#pybdy.nemo_bdy_extr_tm3.Extract.time_interp)
            - [`Extract.write_out()`](pybdy.md#pybdy.nemo_bdy_extr_tm3.Extract.write_out)
    - [pybdy.nemo_bdy_gen_c module](pybdy.md#module-pybdy.nemo_bdy_gen_c)
        - [`Boundary`](pybdy.md#pybdy.nemo_bdy_gen_c.Boundary)
            - [`Boundary.__init__()`](pybdy.md#pybdy.nemo_bdy_gen_c.Boundary.__init__)
            - [`Boundary.fill()`](pybdy.md#pybdy.nemo_bdy_gen_c.Boundary.fill)
            - [`Boundary.find_bdy()`](pybdy.md#pybdy.nemo_bdy_gen_c.Boundary.find_bdy)
            - [`Boundary.remove_duplicate_points()`](pybdy.md#pybdy.nemo_bdy_gen_c.Boundary.remove_duplicate_points)
            - [`Boundary.remove_landpoints_open_ocean()`](pybdy.md#pybdy.nemo_bdy_gen_c.Boundary.remove_landpoints_open_ocean)
            - [`Boundary.unique_rows()`](pybdy.md#pybdy.nemo_bdy_gen_c.Boundary.unique_rows)
    - [pybdy.nemo_bdy_grid_angle module](pybdy.md#module-pybdy.nemo_bdy_grid_angle)
        - [`GridAngle`](pybdy.md#pybdy.nemo_bdy_grid_angle.GridAngle)
            - [`GridAngle.__init__()`](pybdy.md#pybdy.nemo_bdy_grid_angle.GridAngle.__init__)
            - [`GridAngle.get_lam_phi()`](pybdy.md#pybdy.nemo_bdy_grid_angle.GridAngle.get_lam_phi)
            - [`GridAngle.get_north_dir()`](pybdy.md#pybdy.nemo_bdy_grid_angle.GridAngle.get_north_dir)
            - [`GridAngle.get_seg_dir()`](pybdy.md#pybdy.nemo_bdy_grid_angle.GridAngle.get_seg_dir)
            - [`GridAngle.get_sin_cos()`](pybdy.md#pybdy.nemo_bdy_grid_angle.GridAngle.get_sin_cos)
            - [`GridAngle.trig_eq()`](pybdy.md#pybdy.nemo_bdy_grid_angle.GridAngle.trig_eq)
    - [pybdy.nemo_bdy_ice module](pybdy.md#module-pybdy.nemo_bdy_ice)
        - [`BoundaryIce`](pybdy.md#pybdy.nemo_bdy_ice.BoundaryIce)
            - [`BoundaryIce.__init__()`](pybdy.md#pybdy.nemo_bdy_ice.BoundaryIce.__init__)
    - [pybdy.nemo_bdy_ncgen module](pybdy.md#module-pybdy.nemo_bdy_ncgen)
        - [`CreateBDYNetcdfFile()`](pybdy.md#pybdy.nemo_bdy_ncgen.CreateBDYNetcdfFile)
    - [pybdy.nemo_bdy_ncpop module](pybdy.md#module-pybdy.nemo_bdy_ncpop)
        - [`write_data_to_file()`](pybdy.md#pybdy.nemo_bdy_ncpop.write_data_to_file)
    - [pybdy.nemo_bdy_scr_coord module](pybdy.md#module-pybdy.nemo_bdy_scr_coord)
        - [`ScrCoord`](pybdy.md#pybdy.nemo_bdy_scr_coord.ScrCoord)
            - [`ScrCoord.__init__()`](pybdy.md#pybdy.nemo_bdy_scr_coord.ScrCoord.__init__)
    - [pybdy.nemo_bdy_setup module](pybdy.md#module-pybdy.nemo_bdy_setup)
        - [`Setup`](pybdy.md#pybdy.nemo_bdy_setup.Setup)
            - [`Setup.__init__()`](pybdy.md#pybdy.nemo_bdy_setup.Setup.__init__)
            - [`Setup.refresh()`](pybdy.md#pybdy.nemo_bdy_setup.Setup.refresh)
            - [`Setup.variable_info_reader()`](pybdy.md#pybdy.nemo_bdy_setup.Setup.variable_info_reader)
            - [`Setup.write()`](pybdy.md#pybdy.nemo_bdy_setup.Setup.write)
        - [`strip_comments()`](pybdy.md#pybdy.nemo_bdy_setup.strip_comments)
    - [pybdy.nemo_bdy_source_coord module](pybdy.md#module-pybdy.nemo_bdy_source_coord)
        - [`SourceCoord`](pybdy.md#pybdy.nemo_bdy_source_coord.SourceCoord)
            - [`SourceCoord.__init__()`](pybdy.md#pybdy.nemo_bdy_source_coord.SourceCoord.__init__)
    - [pybdy.nemo_bdy_zgrv2 module](pybdy.md#module-pybdy.nemo_bdy_zgrv2)
        - [`get_bdy_depths()`](pybdy.md#pybdy.nemo_bdy_zgrv2.get_bdy_depths)
        - [`get_bdy_depths_old()`](pybdy.md#pybdy.nemo_bdy_zgrv2.get_bdy_depths_old)
        - [`get_bdy_sc_depths()`](pybdy.md#pybdy.nemo_bdy_zgrv2.get_bdy_sc_depths)
    - [pybdy.nemo_coord_gen_pop module](pybdy.md#module-pybdy.nemo_coord_gen_pop)
        - [`Coord`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord)
            - [`Coord.__init__()`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord.__init__)
            - [`Coord.add_vars()`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord.add_vars)
            - [`Coord.build_dict()`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord.build_dict)
            - [`Coord.closeme()`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord.closeme)
            - [`Coord.create_dims()`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord.create_dims)
            - [`Coord.populate()`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord.populate)
            - [`Coord.set_lenvar()`](pybdy.md#pybdy.nemo_coord_gen_pop.Coord.set_lenvar)
    - [pybdy.profiler module](pybdy.md#module-pybdy.profiler)
        - [`Grid`](pybdy.md#pybdy.profiler.Grid)
            - [`Grid.__init__()`](pybdy.md#pybdy.profiler.Grid.__init__)
        - [`process_bdy()`](pybdy.md#pybdy.profiler.process_bdy)
        - [`write_tidal_data()`](pybdy.md#pybdy.profiler.write_tidal_data)
    - [pybdy.pybdy_exe module](pybdy.md#module-pybdy.pybdy_exe)
        - [`main()`](pybdy.md#pybdy.pybdy_exe.main)
    - [pybdy.pybdy_ncml_generator module](pybdy.md#module-pybdy.pybdy_ncml_generator)
        - [`main()`](pybdy.md#pybdy.pybdy_ncml_generator.main)
    - [pybdy.pybdy_settings_editor module](pybdy.md#module-pybdy.pybdy_settings_editor)
        - [`main()`](pybdy.md#pybdy.pybdy_settings_editor.main)
        - [`open_settings_dialog()`](pybdy.md#pybdy.pybdy_settings_editor.open_settings_dialog)
        - [`open_settings_window()`](pybdy.md#pybdy.pybdy_settings_editor.open_settings_window)
    - [pybdy.version module](pybdy.md#module-pybdy.version)
    - [Module contents](pybdy.md#module-pybdy)

[Back to top](#pybdy-documentation)
